// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: core_service.proto

package core_service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	HealthCheckService_HealthCheck_FullMethodName = "/core_service.HealthCheckService/HealthCheck"
)

// HealthCheckServiceClient is the client API for HealthCheckService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthCheckServiceClient interface {
	HealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type healthCheckServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthCheckServiceClient(cc grpc.ClientConnInterface) HealthCheckServiceClient {
	return &healthCheckServiceClient{cc}
}

func (c *healthCheckServiceClient) HealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, HealthCheckService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthCheckServiceServer is the server API for HealthCheckService service.
// All implementations must embed UnimplementedHealthCheckServiceServer
// for forward compatibility.
type HealthCheckServiceServer interface {
	HealthCheck(context.Context, *Empty) (*HealthCheckResponse, error)
	mustEmbedUnimplementedHealthCheckServiceServer()
}

// UnimplementedHealthCheckServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHealthCheckServiceServer struct{}

func (UnimplementedHealthCheckServiceServer) HealthCheck(context.Context, *Empty) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedHealthCheckServiceServer) mustEmbedUnimplementedHealthCheckServiceServer() {}
func (UnimplementedHealthCheckServiceServer) testEmbeddedByValue()                            {}

// UnsafeHealthCheckServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthCheckServiceServer will
// result in compilation errors.
type UnsafeHealthCheckServiceServer interface {
	mustEmbedUnimplementedHealthCheckServiceServer()
}

func RegisterHealthCheckServiceServer(s grpc.ServiceRegistrar, srv HealthCheckServiceServer) {
	// If the following call pancis, it indicates UnimplementedHealthCheckServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HealthCheckService_ServiceDesc, srv)
}

func _HealthCheckService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthCheckServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthCheckService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthCheckServiceServer).HealthCheck(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthCheckService_ServiceDesc is the grpc.ServiceDesc for HealthCheckService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthCheckService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core_service.HealthCheckService",
	HandlerType: (*HealthCheckServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HealthCheck",
			Handler:    _HealthCheckService_HealthCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core_service.proto",
}

const (
	LeadService_Create_FullMethodName             = "/core_service.LeadService/Create"
	LeadService_GetList_FullMethodName            = "/core_service.LeadService/GetList"
	LeadService_Update_FullMethodName             = "/core_service.LeadService/Update"
	LeadService_Delete_FullMethodName             = "/core_service.LeadService/Delete"
	LeadService_GetListSection_FullMethodName     = "/core_service.LeadService/GetListSection"
	LeadService_GetLeadReports_FullMethodName     = "/core_service.LeadService/GetLeadReports"
	LeadService_GetActiveLeadCount_FullMethodName = "/core_service.LeadService/GetActiveLeadCount"
)

// LeadServiceClient is the client API for LeadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LeadServiceClient interface {
	Create(ctx context.Context, in *Lead, opts ...grpc.CallOption) (*Lead, error)
	GetList(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*GetLeadListResponse, error)
	Update(ctx context.Context, in *Lead, opts ...grpc.CallOption) (*Lead, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	GetListSection(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetListSectionResponse, error)
	GetLeadReports(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*GetLeadReportsResponse, error)
	GetActiveLeadCount(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetActiveLeadCountResponse, error)
}

type leadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLeadServiceClient(cc grpc.ClientConnInterface) LeadServiceClient {
	return &leadServiceClient{cc}
}

func (c *leadServiceClient) Create(ctx context.Context, in *Lead, opts ...grpc.CallOption) (*Lead, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Lead)
	err := c.cc.Invoke(ctx, LeadService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) GetList(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*GetLeadListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLeadListResponse)
	err := c.cc.Invoke(ctx, LeadService_GetList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) Update(ctx context.Context, in *Lead, opts ...grpc.CallOption) (*Lead, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Lead)
	err := c.cc.Invoke(ctx, LeadService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LeadService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) GetListSection(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetListSectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetListSectionResponse)
	err := c.cc.Invoke(ctx, LeadService_GetListSection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) GetLeadReports(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*GetLeadReportsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLeadReportsResponse)
	err := c.cc.Invoke(ctx, LeadService_GetLeadReports_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadServiceClient) GetActiveLeadCount(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetActiveLeadCountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActiveLeadCountResponse)
	err := c.cc.Invoke(ctx, LeadService_GetActiveLeadCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LeadServiceServer is the server API for LeadService service.
// All implementations must embed UnimplementedLeadServiceServer
// for forward compatibility.
type LeadServiceServer interface {
	Create(context.Context, *Lead) (*Lead, error)
	GetList(context.Context, *GetListFilter) (*GetLeadListResponse, error)
	Update(context.Context, *Lead) (*Lead, error)
	Delete(context.Context, *Id) (*Empty, error)
	GetListSection(context.Context, *Empty) (*GetListSectionResponse, error)
	GetLeadReports(context.Context, *GetListFilter) (*GetLeadReportsResponse, error)
	GetActiveLeadCount(context.Context, *Empty) (*GetActiveLeadCountResponse, error)
	mustEmbedUnimplementedLeadServiceServer()
}

// UnimplementedLeadServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLeadServiceServer struct{}

func (UnimplementedLeadServiceServer) Create(context.Context, *Lead) (*Lead, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedLeadServiceServer) GetList(context.Context, *GetListFilter) (*GetLeadListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetList not implemented")
}
func (UnimplementedLeadServiceServer) Update(context.Context, *Lead) (*Lead, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedLeadServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedLeadServiceServer) GetListSection(context.Context, *Empty) (*GetListSectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetListSection not implemented")
}
func (UnimplementedLeadServiceServer) GetLeadReports(context.Context, *GetListFilter) (*GetLeadReportsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLeadReports not implemented")
}
func (UnimplementedLeadServiceServer) GetActiveLeadCount(context.Context, *Empty) (*GetActiveLeadCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveLeadCount not implemented")
}
func (UnimplementedLeadServiceServer) mustEmbedUnimplementedLeadServiceServer() {}
func (UnimplementedLeadServiceServer) testEmbeddedByValue()                     {}

// UnsafeLeadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LeadServiceServer will
// result in compilation errors.
type UnsafeLeadServiceServer interface {
	mustEmbedUnimplementedLeadServiceServer()
}

func RegisterLeadServiceServer(s grpc.ServiceRegistrar, srv LeadServiceServer) {
	// If the following call pancis, it indicates UnimplementedLeadServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LeadService_ServiceDesc, srv)
}

func _LeadService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Lead)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).Create(ctx, req.(*Lead))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_GetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).GetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadService_GetList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).GetList(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Lead)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).Update(ctx, req.(*Lead))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_GetListSection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).GetListSection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadService_GetListSection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).GetListSection(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_GetLeadReports_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).GetLeadReports(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadService_GetLeadReports_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).GetLeadReports(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadService_GetActiveLeadCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadServiceServer).GetActiveLeadCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadService_GetActiveLeadCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadServiceServer).GetActiveLeadCount(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// LeadService_ServiceDesc is the grpc.ServiceDesc for LeadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LeadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core_service.LeadService",
	HandlerType: (*LeadServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _LeadService_Create_Handler,
		},
		{
			MethodName: "GetList",
			Handler:    _LeadService_GetList_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _LeadService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _LeadService_Delete_Handler,
		},
		{
			MethodName: "GetListSection",
			Handler:    _LeadService_GetListSection_Handler,
		},
		{
			MethodName: "GetLeadReports",
			Handler:    _LeadService_GetLeadReports_Handler,
		},
		{
			MethodName: "GetActiveLeadCount",
			Handler:    _LeadService_GetActiveLeadCount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core_service.proto",
}

const (
	ExpectService_Create_FullMethodName = "/core_service.ExpectService/Create"
	ExpectService_Update_FullMethodName = "/core_service.ExpectService/Update"
	ExpectService_Delete_FullMethodName = "/core_service.ExpectService/Delete"
)

// ExpectServiceClient is the client API for ExpectService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExpectServiceClient interface {
	Create(ctx context.Context, in *Expect, opts ...grpc.CallOption) (*Expect, error)
	Update(ctx context.Context, in *Expect, opts ...grpc.CallOption) (*Expect, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
}

type expectServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewExpectServiceClient(cc grpc.ClientConnInterface) ExpectServiceClient {
	return &expectServiceClient{cc}
}

func (c *expectServiceClient) Create(ctx context.Context, in *Expect, opts ...grpc.CallOption) (*Expect, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Expect)
	err := c.cc.Invoke(ctx, ExpectService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expectServiceClient) Update(ctx context.Context, in *Expect, opts ...grpc.CallOption) (*Expect, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Expect)
	err := c.cc.Invoke(ctx, ExpectService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expectServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ExpectService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExpectServiceServer is the server API for ExpectService service.
// All implementations must embed UnimplementedExpectServiceServer
// for forward compatibility.
type ExpectServiceServer interface {
	Create(context.Context, *Expect) (*Expect, error)
	Update(context.Context, *Expect) (*Expect, error)
	Delete(context.Context, *Id) (*Empty, error)
	mustEmbedUnimplementedExpectServiceServer()
}

// UnimplementedExpectServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedExpectServiceServer struct{}

func (UnimplementedExpectServiceServer) Create(context.Context, *Expect) (*Expect, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedExpectServiceServer) Update(context.Context, *Expect) (*Expect, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedExpectServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedExpectServiceServer) mustEmbedUnimplementedExpectServiceServer() {}
func (UnimplementedExpectServiceServer) testEmbeddedByValue()                       {}

// UnsafeExpectServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExpectServiceServer will
// result in compilation errors.
type UnsafeExpectServiceServer interface {
	mustEmbedUnimplementedExpectServiceServer()
}

func RegisterExpectServiceServer(s grpc.ServiceRegistrar, srv ExpectServiceServer) {
	// If the following call pancis, it indicates UnimplementedExpectServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ExpectService_ServiceDesc, srv)
}

func _ExpectService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Expect)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpectServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExpectService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpectServiceServer).Create(ctx, req.(*Expect))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpectService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Expect)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpectServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExpectService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpectServiceServer).Update(ctx, req.(*Expect))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpectService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpectServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExpectService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpectServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// ExpectService_ServiceDesc is the grpc.ServiceDesc for ExpectService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExpectService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core_service.ExpectService",
	HandlerType: (*ExpectServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ExpectService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ExpectService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ExpectService_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core_service.proto",
}

const (
	SetService_Create_FullMethodName        = "/core_service.SetService/Create"
	SetService_Update_FullMethodName        = "/core_service.SetService/Update"
	SetService_Delete_FullMethodName        = "/core_service.SetService/Delete"
	SetService_ChangeToGroup_FullMethodName = "/core_service.SetService/ChangeToGroup"
	SetService_GetById_FullMethodName       = "/core_service.SetService/GetById"
)

// SetServiceClient is the client API for SetService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SetServiceClient interface {
	Create(ctx context.Context, in *Set, opts ...grpc.CallOption) (*Set, error)
	Update(ctx context.Context, in *Set, opts ...grpc.CallOption) (*Set, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ChangeToGroup(ctx context.Context, in *ChangeToGroupRequest, opts ...grpc.CallOption) (*Empty, error)
	GetById(ctx context.Context, in *Id, opts ...grpc.CallOption) (*SetDataResponse, error)
}

type setServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSetServiceClient(cc grpc.ClientConnInterface) SetServiceClient {
	return &setServiceClient{cc}
}

func (c *setServiceClient) Create(ctx context.Context, in *Set, opts ...grpc.CallOption) (*Set, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Set)
	err := c.cc.Invoke(ctx, SetService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *setServiceClient) Update(ctx context.Context, in *Set, opts ...grpc.CallOption) (*Set, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Set)
	err := c.cc.Invoke(ctx, SetService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *setServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, SetService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *setServiceClient) ChangeToGroup(ctx context.Context, in *ChangeToGroupRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, SetService_ChangeToGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *setServiceClient) GetById(ctx context.Context, in *Id, opts ...grpc.CallOption) (*SetDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetDataResponse)
	err := c.cc.Invoke(ctx, SetService_GetById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SetServiceServer is the server API for SetService service.
// All implementations must embed UnimplementedSetServiceServer
// for forward compatibility.
type SetServiceServer interface {
	Create(context.Context, *Set) (*Set, error)
	Update(context.Context, *Set) (*Set, error)
	Delete(context.Context, *Id) (*Empty, error)
	ChangeToGroup(context.Context, *ChangeToGroupRequest) (*Empty, error)
	GetById(context.Context, *Id) (*SetDataResponse, error)
	mustEmbedUnimplementedSetServiceServer()
}

// UnimplementedSetServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSetServiceServer struct{}

func (UnimplementedSetServiceServer) Create(context.Context, *Set) (*Set, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedSetServiceServer) Update(context.Context, *Set) (*Set, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedSetServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedSetServiceServer) ChangeToGroup(context.Context, *ChangeToGroupRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeToGroup not implemented")
}
func (UnimplementedSetServiceServer) GetById(context.Context, *Id) (*SetDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetById not implemented")
}
func (UnimplementedSetServiceServer) mustEmbedUnimplementedSetServiceServer() {}
func (UnimplementedSetServiceServer) testEmbeddedByValue()                    {}

// UnsafeSetServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SetServiceServer will
// result in compilation errors.
type UnsafeSetServiceServer interface {
	mustEmbedUnimplementedSetServiceServer()
}

func RegisterSetServiceServer(s grpc.ServiceRegistrar, srv SetServiceServer) {
	// If the following call pancis, it indicates UnimplementedSetServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SetService_ServiceDesc, srv)
}

func _SetService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Set)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SetService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetServiceServer).Create(ctx, req.(*Set))
	}
	return interceptor(ctx, in, info, handler)
}

func _SetService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Set)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SetService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetServiceServer).Update(ctx, req.(*Set))
	}
	return interceptor(ctx, in, info, handler)
}

func _SetService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SetService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _SetService_ChangeToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeToGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetServiceServer).ChangeToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SetService_ChangeToGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetServiceServer).ChangeToGroup(ctx, req.(*ChangeToGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SetService_GetById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetServiceServer).GetById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SetService_GetById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetServiceServer).GetById(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// SetService_ServiceDesc is the grpc.ServiceDesc for SetService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SetService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core_service.SetService",
	HandlerType: (*SetServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _SetService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _SetService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _SetService_Delete_Handler,
		},
		{
			MethodName: "ChangeToGroup",
			Handler:    _SetService_ChangeToGroup_Handler,
		},
		{
			MethodName: "GetById",
			Handler:    _SetService_GetById_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core_service.proto",
}

const (
	LeadDataService_Create_FullMethodName          = "/core_service.LeadDataService/Create"
	LeadDataService_Update_FullMethodName          = "/core_service.LeadDataService/Update"
	LeadDataService_Delete_FullMethodName          = "/core_service.LeadDataService/Delete"
	LeadDataService_ChangeLeadPlace_FullMethodName = "/core_service.LeadDataService/ChangeLeadPlace"
)

// LeadDataServiceClient is the client API for LeadDataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LeadDataServiceClient interface {
	Create(ctx context.Context, in *LeadData, opts ...grpc.CallOption) (*LeadData, error)
	Update(ctx context.Context, in *LeadData, opts ...grpc.CallOption) (*LeadData, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	ChangeLeadPlace(ctx context.Context, in *ChangeLeadPlaceRequest, opts ...grpc.CallOption) (*Empty, error)
}

type leadDataServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLeadDataServiceClient(cc grpc.ClientConnInterface) LeadDataServiceClient {
	return &leadDataServiceClient{cc}
}

func (c *leadDataServiceClient) Create(ctx context.Context, in *LeadData, opts ...grpc.CallOption) (*LeadData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LeadData)
	err := c.cc.Invoke(ctx, LeadDataService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadDataServiceClient) Update(ctx context.Context, in *LeadData, opts ...grpc.CallOption) (*LeadData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LeadData)
	err := c.cc.Invoke(ctx, LeadDataService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadDataServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LeadDataService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leadDataServiceClient) ChangeLeadPlace(ctx context.Context, in *ChangeLeadPlaceRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LeadDataService_ChangeLeadPlace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LeadDataServiceServer is the server API for LeadDataService service.
// All implementations must embed UnimplementedLeadDataServiceServer
// for forward compatibility.
type LeadDataServiceServer interface {
	Create(context.Context, *LeadData) (*LeadData, error)
	Update(context.Context, *LeadData) (*LeadData, error)
	Delete(context.Context, *Id) (*Empty, error)
	ChangeLeadPlace(context.Context, *ChangeLeadPlaceRequest) (*Empty, error)
	mustEmbedUnimplementedLeadDataServiceServer()
}

// UnimplementedLeadDataServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLeadDataServiceServer struct{}

func (UnimplementedLeadDataServiceServer) Create(context.Context, *LeadData) (*LeadData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedLeadDataServiceServer) Update(context.Context, *LeadData) (*LeadData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedLeadDataServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedLeadDataServiceServer) ChangeLeadPlace(context.Context, *ChangeLeadPlaceRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeLeadPlace not implemented")
}
func (UnimplementedLeadDataServiceServer) mustEmbedUnimplementedLeadDataServiceServer() {}
func (UnimplementedLeadDataServiceServer) testEmbeddedByValue()                         {}

// UnsafeLeadDataServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LeadDataServiceServer will
// result in compilation errors.
type UnsafeLeadDataServiceServer interface {
	mustEmbedUnimplementedLeadDataServiceServer()
}

func RegisterLeadDataServiceServer(s grpc.ServiceRegistrar, srv LeadDataServiceServer) {
	// If the following call pancis, it indicates UnimplementedLeadDataServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LeadDataService_ServiceDesc, srv)
}

func _LeadDataService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeadData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadDataServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadDataService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadDataServiceServer).Create(ctx, req.(*LeadData))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadDataService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeadData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadDataServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadDataService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadDataServiceServer).Update(ctx, req.(*LeadData))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadDataService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadDataServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadDataService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadDataServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeadDataService_ChangeLeadPlace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeLeadPlaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeadDataServiceServer).ChangeLeadPlace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeadDataService_ChangeLeadPlace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeadDataServiceServer).ChangeLeadPlace(ctx, req.(*ChangeLeadPlaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LeadDataService_ServiceDesc is the grpc.ServiceDesc for LeadDataService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LeadDataService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core_service.LeadDataService",
	HandlerType: (*LeadDataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _LeadDataService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _LeadDataService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _LeadDataService_Delete_Handler,
		},
		{
			MethodName: "ChangeLeadPlace",
			Handler:    _LeadDataService_ChangeLeadPlace_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core_service.proto",
}
