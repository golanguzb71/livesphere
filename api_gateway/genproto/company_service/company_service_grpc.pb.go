// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.12.4
// source: company_service.proto

package company_service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	HealthCheckService_HealthCheck_FullMethodName = "/company_service.HealthCheckService/HealthCheck"
)

// HealthCheckServiceClient is the client API for HealthCheckService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthCheckServiceClient interface {
	HealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type healthCheckServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthCheckServiceClient(cc grpc.ClientConnInterface) HealthCheckServiceClient {
	return &healthCheckServiceClient{cc}
}

func (c *healthCheckServiceClient) HealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, HealthCheckService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthCheckServiceServer is the server API for HealthCheckService service.
// All implementations must embed UnimplementedHealthCheckServiceServer
// for forward compatibility
type HealthCheckServiceServer interface {
	HealthCheck(context.Context, *Empty) (*HealthCheckResponse, error)
	mustEmbedUnimplementedHealthCheckServiceServer()
}

// UnimplementedHealthCheckServiceServer must be embedded to have forward compatible implementations.
type UnimplementedHealthCheckServiceServer struct {
}

func (UnimplementedHealthCheckServiceServer) HealthCheck(context.Context, *Empty) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedHealthCheckServiceServer) mustEmbedUnimplementedHealthCheckServiceServer() {}

// UnsafeHealthCheckServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthCheckServiceServer will
// result in compilation errors.
type UnsafeHealthCheckServiceServer interface {
	mustEmbedUnimplementedHealthCheckServiceServer()
}

func RegisterHealthCheckServiceServer(s grpc.ServiceRegistrar, srv HealthCheckServiceServer) {
	s.RegisterService(&HealthCheckService_ServiceDesc, srv)
}

func _HealthCheckService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthCheckServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthCheckService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthCheckServiceServer).HealthCheck(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthCheckService_ServiceDesc is the grpc.ServiceDesc for HealthCheckService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthCheckService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.HealthCheckService",
	HandlerType: (*HealthCheckServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HealthCheck",
			Handler:    _HealthCheckService_HealthCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	CompanyService_Create_FullMethodName    = "/company_service.CompanyService/Create"
	CompanyService_Update_FullMethodName    = "/company_service.CompanyService/Update"
	CompanyService_Delete_FullMethodName    = "/company_service.CompanyService/Delete"
	CompanyService_Get_FullMethodName       = "/company_service.CompanyService/Get"
	CompanyService_Find_FullMethodName      = "/company_service.CompanyService/Find"
	CompanyService_NewUpdate_FullMethodName = "/company_service.CompanyService/NewUpdate"
)

// CompanyServiceClient is the client API for CompanyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CompanyServiceClient interface {
	Create(ctx context.Context, in *Company, opts ...grpc.CallOption) (*Company, error)
	Update(ctx context.Context, in *Company, opts ...grpc.CallOption) (*Company, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Company, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*CompanyList, error)
	NewUpdate(ctx context.Context, in *UpdateMessage, opts ...grpc.CallOption) (*UpdateMessage, error)
}

type companyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCompanyServiceClient(cc grpc.ClientConnInterface) CompanyServiceClient {
	return &companyServiceClient{cc}
}

func (c *companyServiceClient) Create(ctx context.Context, in *Company, opts ...grpc.CallOption) (*Company, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Company)
	err := c.cc.Invoke(ctx, CompanyService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyServiceClient) Update(ctx context.Context, in *Company, opts ...grpc.CallOption) (*Company, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Company)
	err := c.cc.Invoke(ctx, CompanyService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, CompanyService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Company, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Company)
	err := c.cc.Invoke(ctx, CompanyService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*CompanyList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompanyList)
	err := c.cc.Invoke(ctx, CompanyService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyServiceClient) NewUpdate(ctx context.Context, in *UpdateMessage, opts ...grpc.CallOption) (*UpdateMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateMessage)
	err := c.cc.Invoke(ctx, CompanyService_NewUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CompanyServiceServer is the server API for CompanyService service.
// All implementations must embed UnimplementedCompanyServiceServer
// for forward compatibility
type CompanyServiceServer interface {
	Create(context.Context, *Company) (*Company, error)
	Update(context.Context, *Company) (*Company, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*Company, error)
	Find(context.Context, *GetListFilter) (*CompanyList, error)
	NewUpdate(context.Context, *UpdateMessage) (*UpdateMessage, error)
	mustEmbedUnimplementedCompanyServiceServer()
}

// UnimplementedCompanyServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCompanyServiceServer struct {
}

func (UnimplementedCompanyServiceServer) Create(context.Context, *Company) (*Company, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedCompanyServiceServer) Update(context.Context, *Company) (*Company, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedCompanyServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedCompanyServiceServer) Get(context.Context, *Id) (*Company, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedCompanyServiceServer) Find(context.Context, *GetListFilter) (*CompanyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedCompanyServiceServer) NewUpdate(context.Context, *UpdateMessage) (*UpdateMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewUpdate not implemented")
}
func (UnimplementedCompanyServiceServer) mustEmbedUnimplementedCompanyServiceServer() {}

// UnsafeCompanyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CompanyServiceServer will
// result in compilation errors.
type UnsafeCompanyServiceServer interface {
	mustEmbedUnimplementedCompanyServiceServer()
}

func RegisterCompanyServiceServer(s grpc.ServiceRegistrar, srv CompanyServiceServer) {
	s.RegisterService(&CompanyService_ServiceDesc, srv)
}

func _CompanyService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Company)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CompanyService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyServiceServer).Create(ctx, req.(*Company))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompanyService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Company)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CompanyService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyServiceServer).Update(ctx, req.(*Company))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompanyService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CompanyService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompanyService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CompanyService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompanyService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CompanyService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompanyService_NewUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyServiceServer).NewUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CompanyService_NewUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyServiceServer).NewUpdate(ctx, req.(*UpdateMessage))
	}
	return interceptor(ctx, in, info, handler)
}

// CompanyService_ServiceDesc is the grpc.ServiceDesc for CompanyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CompanyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.CompanyService",
	HandlerType: (*CompanyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _CompanyService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _CompanyService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _CompanyService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _CompanyService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _CompanyService_Find_Handler,
		},
		{
			MethodName: "NewUpdate",
			Handler:    _CompanyService_NewUpdate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	CompanyUserService_Create_FullMethodName      = "/company_service.CompanyUserService/Create"
	CompanyUserService_Update_FullMethodName      = "/company_service.CompanyUserService/Update"
	CompanyUserService_Delete_FullMethodName      = "/company_service.CompanyUserService/Delete"
	CompanyUserService_Get_FullMethodName         = "/company_service.CompanyUserService/Get"
	CompanyUserService_Find_FullMethodName        = "/company_service.CompanyUserService/Find"
	CompanyUserService_MultipleGet_FullMethodName = "/company_service.CompanyUserService/MultipleGet"
)

// CompanyUserServiceClient is the client API for CompanyUserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CompanyUserServiceClient interface {
	Create(ctx context.Context, in *CompanyUser, opts ...grpc.CallOption) (*CompanyUserResponse, error)
	Update(ctx context.Context, in *CompanyUserUpdate, opts ...grpc.CallOption) (*CompanyUserUpdate, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*CompanyUserResponse, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*CompanyUserList, error)
	MultipleGet(ctx context.Context, in *MultipleGetRequest, opts ...grpc.CallOption) (*CompanyUserList, error)
}

type companyUserServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCompanyUserServiceClient(cc grpc.ClientConnInterface) CompanyUserServiceClient {
	return &companyUserServiceClient{cc}
}

func (c *companyUserServiceClient) Create(ctx context.Context, in *CompanyUser, opts ...grpc.CallOption) (*CompanyUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompanyUserResponse)
	err := c.cc.Invoke(ctx, CompanyUserService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyUserServiceClient) Update(ctx context.Context, in *CompanyUserUpdate, opts ...grpc.CallOption) (*CompanyUserUpdate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompanyUserUpdate)
	err := c.cc.Invoke(ctx, CompanyUserService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyUserServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, CompanyUserService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyUserServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*CompanyUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompanyUserResponse)
	err := c.cc.Invoke(ctx, CompanyUserService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyUserServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*CompanyUserList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompanyUserList)
	err := c.cc.Invoke(ctx, CompanyUserService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyUserServiceClient) MultipleGet(ctx context.Context, in *MultipleGetRequest, opts ...grpc.CallOption) (*CompanyUserList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompanyUserList)
	err := c.cc.Invoke(ctx, CompanyUserService_MultipleGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CompanyUserServiceServer is the server API for CompanyUserService service.
// All implementations must embed UnimplementedCompanyUserServiceServer
// for forward compatibility
type CompanyUserServiceServer interface {
	Create(context.Context, *CompanyUser) (*CompanyUserResponse, error)
	Update(context.Context, *CompanyUserUpdate) (*CompanyUserUpdate, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*CompanyUserResponse, error)
	Find(context.Context, *GetListFilter) (*CompanyUserList, error)
	MultipleGet(context.Context, *MultipleGetRequest) (*CompanyUserList, error)
	mustEmbedUnimplementedCompanyUserServiceServer()
}

// UnimplementedCompanyUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCompanyUserServiceServer struct {
}

func (UnimplementedCompanyUserServiceServer) Create(context.Context, *CompanyUser) (*CompanyUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedCompanyUserServiceServer) Update(context.Context, *CompanyUserUpdate) (*CompanyUserUpdate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedCompanyUserServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedCompanyUserServiceServer) Get(context.Context, *Id) (*CompanyUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedCompanyUserServiceServer) Find(context.Context, *GetListFilter) (*CompanyUserList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedCompanyUserServiceServer) MultipleGet(context.Context, *MultipleGetRequest) (*CompanyUserList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultipleGet not implemented")
}
func (UnimplementedCompanyUserServiceServer) mustEmbedUnimplementedCompanyUserServiceServer() {}

// UnsafeCompanyUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CompanyUserServiceServer will
// result in compilation errors.
type UnsafeCompanyUserServiceServer interface {
	mustEmbedUnimplementedCompanyUserServiceServer()
}

func RegisterCompanyUserServiceServer(s grpc.ServiceRegistrar, srv CompanyUserServiceServer) {
	s.RegisterService(&CompanyUserService_ServiceDesc, srv)
}

func _CompanyUserService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompanyUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyUserServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CompanyUserService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyUserServiceServer).Create(ctx, req.(*CompanyUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompanyUserService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompanyUserUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyUserServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CompanyUserService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyUserServiceServer).Update(ctx, req.(*CompanyUserUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompanyUserService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyUserServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CompanyUserService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyUserServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompanyUserService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyUserServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CompanyUserService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyUserServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompanyUserService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyUserServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CompanyUserService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyUserServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompanyUserService_MultipleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultipleGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyUserServiceServer).MultipleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CompanyUserService_MultipleGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyUserServiceServer).MultipleGet(ctx, req.(*MultipleGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CompanyUserService_ServiceDesc is the grpc.ServiceDesc for CompanyUserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CompanyUserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.CompanyUserService",
	HandlerType: (*CompanyUserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _CompanyUserService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _CompanyUserService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _CompanyUserService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _CompanyUserService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _CompanyUserService_Find_Handler,
		},
		{
			MethodName: "MultipleGet",
			Handler:    _CompanyUserService_MultipleGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	InvitationService_Create_FullMethodName = "/company_service.InvitationService/Create"
	InvitationService_Update_FullMethodName = "/company_service.InvitationService/Update"
	InvitationService_Get_FullMethodName    = "/company_service.InvitationService/Get"
)

// InvitationServiceClient is the client API for InvitationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InvitationServiceClient interface {
	Create(ctx context.Context, in *Invitation, opts ...grpc.CallOption) (*Invitation, error)
	Update(ctx context.Context, in *InvitationUpdateStatus, opts ...grpc.CallOption) (*InvitationUpdateStatus, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Invitation, error)
}

type invitationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInvitationServiceClient(cc grpc.ClientConnInterface) InvitationServiceClient {
	return &invitationServiceClient{cc}
}

func (c *invitationServiceClient) Create(ctx context.Context, in *Invitation, opts ...grpc.CallOption) (*Invitation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Invitation)
	err := c.cc.Invoke(ctx, InvitationService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invitationServiceClient) Update(ctx context.Context, in *InvitationUpdateStatus, opts ...grpc.CallOption) (*InvitationUpdateStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InvitationUpdateStatus)
	err := c.cc.Invoke(ctx, InvitationService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invitationServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Invitation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Invitation)
	err := c.cc.Invoke(ctx, InvitationService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InvitationServiceServer is the server API for InvitationService service.
// All implementations must embed UnimplementedInvitationServiceServer
// for forward compatibility
type InvitationServiceServer interface {
	Create(context.Context, *Invitation) (*Invitation, error)
	Update(context.Context, *InvitationUpdateStatus) (*InvitationUpdateStatus, error)
	Get(context.Context, *Id) (*Invitation, error)
	mustEmbedUnimplementedInvitationServiceServer()
}

// UnimplementedInvitationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInvitationServiceServer struct {
}

func (UnimplementedInvitationServiceServer) Create(context.Context, *Invitation) (*Invitation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedInvitationServiceServer) Update(context.Context, *InvitationUpdateStatus) (*InvitationUpdateStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedInvitationServiceServer) Get(context.Context, *Id) (*Invitation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInvitationServiceServer) mustEmbedUnimplementedInvitationServiceServer() {}

// UnsafeInvitationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InvitationServiceServer will
// result in compilation errors.
type UnsafeInvitationServiceServer interface {
	mustEmbedUnimplementedInvitationServiceServer()
}

func RegisterInvitationServiceServer(s grpc.ServiceRegistrar, srv InvitationServiceServer) {
	s.RegisterService(&InvitationService_ServiceDesc, srv)
}

func _InvitationService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Invitation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvitationServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InvitationService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvitationServiceServer).Create(ctx, req.(*Invitation))
	}
	return interceptor(ctx, in, info, handler)
}

func _InvitationService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvitationUpdateStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvitationServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InvitationService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvitationServiceServer).Update(ctx, req.(*InvitationUpdateStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _InvitationService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvitationServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InvitationService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvitationServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// InvitationService_ServiceDesc is the grpc.ServiceDesc for InvitationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InvitationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.InvitationService",
	HandlerType: (*InvitationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _InvitationService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _InvitationService_Update_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InvitationService_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	UnitService_Create_FullMethodName       = "/company_service.UnitService/Create"
	UnitService_UpdateStatus_FullMethodName = "/company_service.UnitService/UpdateStatus"
	UnitService_Update_FullMethodName       = "/company_service.UnitService/Update"
	UnitService_Find_FullMethodName         = "/company_service.UnitService/Find"
	UnitService_Get_FullMethodName          = "/company_service.UnitService/Get"
	UnitService_ReactiveUnit_FullMethodName = "/company_service.UnitService/ReactiveUnit"
	UnitService_UploadUnit_FullMethodName   = "/company_service.UnitService/UploadUnit"
	UnitService_MultipleGet_FullMethodName  = "/company_service.UnitService/MultipleGet"
	UnitService_UnitTracking_FullMethodName = "/company_service.UnitService/UnitTracking"
)

// UnitServiceClient is the client API for UnitService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UnitServiceClient interface {
	Create(ctx context.Context, in *Unit, opts ...grpc.CallOption) (*Unit, error)
	UpdateStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*Empty, error)
	Update(ctx context.Context, in *Unit, opts ...grpc.CallOption) (*Unit, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*UnitList, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Unit, error)
	ReactiveUnit(ctx context.Context, in *ReactivatedStatus, opts ...grpc.CallOption) (*ReactivatedStatus, error)
	UploadUnit(ctx context.Context, in *UploadUnits, opts ...grpc.CallOption) (*UploadUnits, error)
	MultipleGet(ctx context.Context, in *MultipleGetRequest, opts ...grpc.CallOption) (*MultipleUnitList, error)
	UnitTracking(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*UnitList, error)
}

type unitServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUnitServiceClient(cc grpc.ClientConnInterface) UnitServiceClient {
	return &unitServiceClient{cc}
}

func (c *unitServiceClient) Create(ctx context.Context, in *Unit, opts ...grpc.CallOption) (*Unit, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Unit)
	err := c.cc.Invoke(ctx, UnitService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitServiceClient) UpdateStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UnitService_UpdateStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitServiceClient) Update(ctx context.Context, in *Unit, opts ...grpc.CallOption) (*Unit, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Unit)
	err := c.cc.Invoke(ctx, UnitService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*UnitList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnitList)
	err := c.cc.Invoke(ctx, UnitService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Unit, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Unit)
	err := c.cc.Invoke(ctx, UnitService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitServiceClient) ReactiveUnit(ctx context.Context, in *ReactivatedStatus, opts ...grpc.CallOption) (*ReactivatedStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReactivatedStatus)
	err := c.cc.Invoke(ctx, UnitService_ReactiveUnit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitServiceClient) UploadUnit(ctx context.Context, in *UploadUnits, opts ...grpc.CallOption) (*UploadUnits, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadUnits)
	err := c.cc.Invoke(ctx, UnitService_UploadUnit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitServiceClient) MultipleGet(ctx context.Context, in *MultipleGetRequest, opts ...grpc.CallOption) (*MultipleUnitList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MultipleUnitList)
	err := c.cc.Invoke(ctx, UnitService_MultipleGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitServiceClient) UnitTracking(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*UnitList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnitList)
	err := c.cc.Invoke(ctx, UnitService_UnitTracking_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UnitServiceServer is the server API for UnitService service.
// All implementations must embed UnimplementedUnitServiceServer
// for forward compatibility
type UnitServiceServer interface {
	Create(context.Context, *Unit) (*Unit, error)
	UpdateStatus(context.Context, *UpdateStatusRequest) (*Empty, error)
	Update(context.Context, *Unit) (*Unit, error)
	Find(context.Context, *GetListFilter) (*UnitList, error)
	Get(context.Context, *Id) (*Unit, error)
	ReactiveUnit(context.Context, *ReactivatedStatus) (*ReactivatedStatus, error)
	UploadUnit(context.Context, *UploadUnits) (*UploadUnits, error)
	MultipleGet(context.Context, *MultipleGetRequest) (*MultipleUnitList, error)
	UnitTracking(context.Context, *GetListFilter) (*UnitList, error)
	mustEmbedUnimplementedUnitServiceServer()
}

// UnimplementedUnitServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUnitServiceServer struct {
}

func (UnimplementedUnitServiceServer) Create(context.Context, *Unit) (*Unit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedUnitServiceServer) UpdateStatus(context.Context, *UpdateStatusRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStatus not implemented")
}
func (UnimplementedUnitServiceServer) Update(context.Context, *Unit) (*Unit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedUnitServiceServer) Find(context.Context, *GetListFilter) (*UnitList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedUnitServiceServer) Get(context.Context, *Id) (*Unit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedUnitServiceServer) ReactiveUnit(context.Context, *ReactivatedStatus) (*ReactivatedStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReactiveUnit not implemented")
}
func (UnimplementedUnitServiceServer) UploadUnit(context.Context, *UploadUnits) (*UploadUnits, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadUnit not implemented")
}
func (UnimplementedUnitServiceServer) MultipleGet(context.Context, *MultipleGetRequest) (*MultipleUnitList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultipleGet not implemented")
}
func (UnimplementedUnitServiceServer) UnitTracking(context.Context, *GetListFilter) (*UnitList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnitTracking not implemented")
}
func (UnimplementedUnitServiceServer) mustEmbedUnimplementedUnitServiceServer() {}

// UnsafeUnitServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UnitServiceServer will
// result in compilation errors.
type UnsafeUnitServiceServer interface {
	mustEmbedUnimplementedUnitServiceServer()
}

func RegisterUnitServiceServer(s grpc.ServiceRegistrar, srv UnitServiceServer) {
	s.RegisterService(&UnitService_ServiceDesc, srv)
}

func _UnitService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Unit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitServiceServer).Create(ctx, req.(*Unit))
	}
	return interceptor(ctx, in, info, handler)
}

func _UnitService_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitServiceServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitService_UpdateStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitServiceServer).UpdateStatus(ctx, req.(*UpdateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UnitService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Unit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitServiceServer).Update(ctx, req.(*Unit))
	}
	return interceptor(ctx, in, info, handler)
}

func _UnitService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _UnitService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UnitService_ReactiveUnit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReactivatedStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitServiceServer).ReactiveUnit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitService_ReactiveUnit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitServiceServer).ReactiveUnit(ctx, req.(*ReactivatedStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _UnitService_UploadUnit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadUnits)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitServiceServer).UploadUnit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitService_UploadUnit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitServiceServer).UploadUnit(ctx, req.(*UploadUnits))
	}
	return interceptor(ctx, in, info, handler)
}

func _UnitService_MultipleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultipleGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitServiceServer).MultipleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitService_MultipleGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitServiceServer).MultipleGet(ctx, req.(*MultipleGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UnitService_UnitTracking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitServiceServer).UnitTracking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitService_UnitTracking_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitServiceServer).UnitTracking(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// UnitService_ServiceDesc is the grpc.ServiceDesc for UnitService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UnitService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.UnitService",
	HandlerType: (*UnitServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _UnitService_Create_Handler,
		},
		{
			MethodName: "UpdateStatus",
			Handler:    _UnitService_UpdateStatus_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _UnitService_Update_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _UnitService_Find_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _UnitService_Get_Handler,
		},
		{
			MethodName: "ReactiveUnit",
			Handler:    _UnitService_ReactiveUnit_Handler,
		},
		{
			MethodName: "UploadUnit",
			Handler:    _UnitService_UploadUnit_Handler,
		},
		{
			MethodName: "MultipleGet",
			Handler:    _UnitService_MultipleGet_Handler,
		},
		{
			MethodName: "UnitTracking",
			Handler:    _UnitService_UnitTracking_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	DriverService_Create_FullMethodName                    = "/company_service.DriverService/Create"
	DriverService_Find_FullMethodName                      = "/company_service.DriverService/Find"
	DriverService_Update_FullMethodName                    = "/company_service.DriverService/Update"
	DriverService_Get_FullMethodName                       = "/company_service.DriverService/Get"
	DriverService_UpdateStatus_FullMethodName              = "/company_service.DriverService/UpdateStatus"
	DriverService_UploadDriverList_FullMethodName          = "/company_service.DriverService/UploadDriverList"
	DriverService_GetDriverLogs_FullMethodName             = "/company_service.DriverService/GetDriverLogs"
	DriverService_GetDriverListWithStatuses_FullMethodName = "/company_service.DriverService/GetDriverListWithStatuses"
	DriverService_GetDriverLogsList_FullMethodName         = "/company_service.DriverService/GetDriverLogsList"
	DriverService_MultipleGet_FullMethodName               = "/company_service.DriverService/MultipleGet"
)

// DriverServiceClient is the client API for DriverService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DriverServiceClient interface {
	Create(ctx context.Context, in *Driver, opts ...grpc.CallOption) (*MutationResponse, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*DriverListResponse, error)
	Update(ctx context.Context, in *Driver, opts ...grpc.CallOption) (*MutationResponse, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Driver, error)
	UpdateStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*Empty, error)
	UploadDriverList(ctx context.Context, in *UploadDrivers, opts ...grpc.CallOption) (*UploadDrivers, error)
	GetDriverLogs(ctx context.Context, in *MultipleGetRequest, opts ...grpc.CallOption) (*Driver, error)
	GetDriverListWithStatuses(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*DriverListResponse, error)
	GetDriverLogsList(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*DriverListResponse, error)
	MultipleGet(ctx context.Context, in *MultipleGetRequest, opts ...grpc.CallOption) (*MultipleDriverList, error)
}

type driverServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDriverServiceClient(cc grpc.ClientConnInterface) DriverServiceClient {
	return &driverServiceClient{cc}
}

func (c *driverServiceClient) Create(ctx context.Context, in *Driver, opts ...grpc.CallOption) (*MutationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MutationResponse)
	err := c.cc.Invoke(ctx, DriverService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*DriverListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DriverListResponse)
	err := c.cc.Invoke(ctx, DriverService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverServiceClient) Update(ctx context.Context, in *Driver, opts ...grpc.CallOption) (*MutationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MutationResponse)
	err := c.cc.Invoke(ctx, DriverService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Driver, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Driver)
	err := c.cc.Invoke(ctx, DriverService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverServiceClient) UpdateStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, DriverService_UpdateStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverServiceClient) UploadDriverList(ctx context.Context, in *UploadDrivers, opts ...grpc.CallOption) (*UploadDrivers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadDrivers)
	err := c.cc.Invoke(ctx, DriverService_UploadDriverList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverServiceClient) GetDriverLogs(ctx context.Context, in *MultipleGetRequest, opts ...grpc.CallOption) (*Driver, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Driver)
	err := c.cc.Invoke(ctx, DriverService_GetDriverLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverServiceClient) GetDriverListWithStatuses(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*DriverListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DriverListResponse)
	err := c.cc.Invoke(ctx, DriverService_GetDriverListWithStatuses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverServiceClient) GetDriverLogsList(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*DriverListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DriverListResponse)
	err := c.cc.Invoke(ctx, DriverService_GetDriverLogsList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverServiceClient) MultipleGet(ctx context.Context, in *MultipleGetRequest, opts ...grpc.CallOption) (*MultipleDriverList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MultipleDriverList)
	err := c.cc.Invoke(ctx, DriverService_MultipleGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DriverServiceServer is the server API for DriverService service.
// All implementations must embed UnimplementedDriverServiceServer
// for forward compatibility
type DriverServiceServer interface {
	Create(context.Context, *Driver) (*MutationResponse, error)
	Find(context.Context, *GetListFilter) (*DriverListResponse, error)
	Update(context.Context, *Driver) (*MutationResponse, error)
	Get(context.Context, *Id) (*Driver, error)
	UpdateStatus(context.Context, *UpdateStatusRequest) (*Empty, error)
	UploadDriverList(context.Context, *UploadDrivers) (*UploadDrivers, error)
	GetDriverLogs(context.Context, *MultipleGetRequest) (*Driver, error)
	GetDriverListWithStatuses(context.Context, *GetListFilter) (*DriverListResponse, error)
	GetDriverLogsList(context.Context, *GetListFilter) (*DriverListResponse, error)
	MultipleGet(context.Context, *MultipleGetRequest) (*MultipleDriverList, error)
	mustEmbedUnimplementedDriverServiceServer()
}

// UnimplementedDriverServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDriverServiceServer struct {
}

func (UnimplementedDriverServiceServer) Create(context.Context, *Driver) (*MutationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedDriverServiceServer) Find(context.Context, *GetListFilter) (*DriverListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedDriverServiceServer) Update(context.Context, *Driver) (*MutationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedDriverServiceServer) Get(context.Context, *Id) (*Driver, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDriverServiceServer) UpdateStatus(context.Context, *UpdateStatusRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStatus not implemented")
}
func (UnimplementedDriverServiceServer) UploadDriverList(context.Context, *UploadDrivers) (*UploadDrivers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadDriverList not implemented")
}
func (UnimplementedDriverServiceServer) GetDriverLogs(context.Context, *MultipleGetRequest) (*Driver, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDriverLogs not implemented")
}
func (UnimplementedDriverServiceServer) GetDriverListWithStatuses(context.Context, *GetListFilter) (*DriverListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDriverListWithStatuses not implemented")
}
func (UnimplementedDriverServiceServer) GetDriverLogsList(context.Context, *GetListFilter) (*DriverListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDriverLogsList not implemented")
}
func (UnimplementedDriverServiceServer) MultipleGet(context.Context, *MultipleGetRequest) (*MultipleDriverList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultipleGet not implemented")
}
func (UnimplementedDriverServiceServer) mustEmbedUnimplementedDriverServiceServer() {}

// UnsafeDriverServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DriverServiceServer will
// result in compilation errors.
type UnsafeDriverServiceServer interface {
	mustEmbedUnimplementedDriverServiceServer()
}

func RegisterDriverServiceServer(s grpc.ServiceRegistrar, srv DriverServiceServer) {
	s.RegisterService(&DriverService_ServiceDesc, srv)
}

func _DriverService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Driver)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriverService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServiceServer).Create(ctx, req.(*Driver))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriverService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriverService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriverService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Driver)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriverService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServiceServer).Update(ctx, req.(*Driver))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriverService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriverService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriverService_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServiceServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriverService_UpdateStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServiceServer).UpdateStatus(ctx, req.(*UpdateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriverService_UploadDriverList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadDrivers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServiceServer).UploadDriverList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriverService_UploadDriverList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServiceServer).UploadDriverList(ctx, req.(*UploadDrivers))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriverService_GetDriverLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultipleGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServiceServer).GetDriverLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriverService_GetDriverLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServiceServer).GetDriverLogs(ctx, req.(*MultipleGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriverService_GetDriverListWithStatuses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServiceServer).GetDriverListWithStatuses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriverService_GetDriverListWithStatuses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServiceServer).GetDriverListWithStatuses(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriverService_GetDriverLogsList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServiceServer).GetDriverLogsList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriverService_GetDriverLogsList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServiceServer).GetDriverLogsList(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriverService_MultipleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultipleGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServiceServer).MultipleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriverService_MultipleGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServiceServer).MultipleGet(ctx, req.(*MultipleGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DriverService_ServiceDesc is the grpc.ServiceDesc for DriverService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DriverService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.DriverService",
	HandlerType: (*DriverServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _DriverService_Create_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _DriverService_Find_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _DriverService_Update_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DriverService_Get_Handler,
		},
		{
			MethodName: "UpdateStatus",
			Handler:    _DriverService_UpdateStatus_Handler,
		},
		{
			MethodName: "UploadDriverList",
			Handler:    _DriverService_UploadDriverList_Handler,
		},
		{
			MethodName: "GetDriverLogs",
			Handler:    _DriverService_GetDriverLogs_Handler,
		},
		{
			MethodName: "GetDriverListWithStatuses",
			Handler:    _DriverService_GetDriverListWithStatuses_Handler,
		},
		{
			MethodName: "GetDriverLogsList",
			Handler:    _DriverService_GetDriverLogsList_Handler,
		},
		{
			MethodName: "MultipleGet",
			Handler:    _DriverService_MultipleGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	DriverDeviceService_Upsert_FullMethodName = "/company_service.DriverDeviceService/Upsert"
	DriverDeviceService_Get_FullMethodName    = "/company_service.DriverDeviceService/Get"
)

// DriverDeviceServiceClient is the client API for DriverDeviceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DriverDeviceServiceClient interface {
	Upsert(ctx context.Context, in *DriverDevice, opts ...grpc.CallOption) (*DriverDevice, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*DriverDevice, error)
}

type driverDeviceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDriverDeviceServiceClient(cc grpc.ClientConnInterface) DriverDeviceServiceClient {
	return &driverDeviceServiceClient{cc}
}

func (c *driverDeviceServiceClient) Upsert(ctx context.Context, in *DriverDevice, opts ...grpc.CallOption) (*DriverDevice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DriverDevice)
	err := c.cc.Invoke(ctx, DriverDeviceService_Upsert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverDeviceServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*DriverDevice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DriverDevice)
	err := c.cc.Invoke(ctx, DriverDeviceService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DriverDeviceServiceServer is the server API for DriverDeviceService service.
// All implementations must embed UnimplementedDriverDeviceServiceServer
// for forward compatibility
type DriverDeviceServiceServer interface {
	Upsert(context.Context, *DriverDevice) (*DriverDevice, error)
	Get(context.Context, *Id) (*DriverDevice, error)
	mustEmbedUnimplementedDriverDeviceServiceServer()
}

// UnimplementedDriverDeviceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDriverDeviceServiceServer struct {
}

func (UnimplementedDriverDeviceServiceServer) Upsert(context.Context, *DriverDevice) (*DriverDevice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upsert not implemented")
}
func (UnimplementedDriverDeviceServiceServer) Get(context.Context, *Id) (*DriverDevice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDriverDeviceServiceServer) mustEmbedUnimplementedDriverDeviceServiceServer() {}

// UnsafeDriverDeviceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DriverDeviceServiceServer will
// result in compilation errors.
type UnsafeDriverDeviceServiceServer interface {
	mustEmbedUnimplementedDriverDeviceServiceServer()
}

func RegisterDriverDeviceServiceServer(s grpc.ServiceRegistrar, srv DriverDeviceServiceServer) {
	s.RegisterService(&DriverDeviceService_ServiceDesc, srv)
}

func _DriverDeviceService_Upsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DriverDevice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverDeviceServiceServer).Upsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriverDeviceService_Upsert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverDeviceServiceServer).Upsert(ctx, req.(*DriverDevice))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriverDeviceService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverDeviceServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriverDeviceService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverDeviceServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// DriverDeviceService_ServiceDesc is the grpc.ServiceDesc for DriverDeviceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DriverDeviceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.DriverDeviceService",
	HandlerType: (*DriverDeviceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Upsert",
			Handler:    _DriverDeviceService_Upsert_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DriverDeviceService_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	AplicationService_Create_FullMethodName                = "/company_service.AplicationService/Create"
	AplicationService_Update_FullMethodName                = "/company_service.AplicationService/Update"
	AplicationService_Delete_FullMethodName                = "/company_service.AplicationService/Delete"
	AplicationService_Get_FullMethodName                   = "/company_service.AplicationService/Get"
	AplicationService_Find_FullMethodName                  = "/company_service.AplicationService/Find"
	AplicationService_AplicationVerify_FullMethodName      = "/company_service.AplicationService/AplicationVerify"
	AplicationService_VerifyAplicationEmail_FullMethodName = "/company_service.AplicationService/VerifyAplicationEmail"
)

// AplicationServiceClient is the client API for AplicationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AplicationServiceClient interface {
	Create(ctx context.Context, in *Aplication, opts ...grpc.CallOption) (*Aplication, error)
	Update(ctx context.Context, in *UpdateAplicationStatus, opts ...grpc.CallOption) (*UpdateAplicationStatus, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Aplication, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*AplicationList, error)
	AplicationVerify(ctx context.Context, in *AplicationStatus, opts ...grpc.CallOption) (*Empty, error)
	VerifyAplicationEmail(ctx context.Context, in *VerifyEmail, opts ...grpc.CallOption) (*Empty, error)
}

type aplicationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAplicationServiceClient(cc grpc.ClientConnInterface) AplicationServiceClient {
	return &aplicationServiceClient{cc}
}

func (c *aplicationServiceClient) Create(ctx context.Context, in *Aplication, opts ...grpc.CallOption) (*Aplication, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Aplication)
	err := c.cc.Invoke(ctx, AplicationService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aplicationServiceClient) Update(ctx context.Context, in *UpdateAplicationStatus, opts ...grpc.CallOption) (*UpdateAplicationStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateAplicationStatus)
	err := c.cc.Invoke(ctx, AplicationService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aplicationServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AplicationService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aplicationServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Aplication, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Aplication)
	err := c.cc.Invoke(ctx, AplicationService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aplicationServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*AplicationList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AplicationList)
	err := c.cc.Invoke(ctx, AplicationService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aplicationServiceClient) AplicationVerify(ctx context.Context, in *AplicationStatus, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AplicationService_AplicationVerify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aplicationServiceClient) VerifyAplicationEmail(ctx context.Context, in *VerifyEmail, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AplicationService_VerifyAplicationEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AplicationServiceServer is the server API for AplicationService service.
// All implementations must embed UnimplementedAplicationServiceServer
// for forward compatibility
type AplicationServiceServer interface {
	Create(context.Context, *Aplication) (*Aplication, error)
	Update(context.Context, *UpdateAplicationStatus) (*UpdateAplicationStatus, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*Aplication, error)
	Find(context.Context, *GetListFilter) (*AplicationList, error)
	AplicationVerify(context.Context, *AplicationStatus) (*Empty, error)
	VerifyAplicationEmail(context.Context, *VerifyEmail) (*Empty, error)
	mustEmbedUnimplementedAplicationServiceServer()
}

// UnimplementedAplicationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAplicationServiceServer struct {
}

func (UnimplementedAplicationServiceServer) Create(context.Context, *Aplication) (*Aplication, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedAplicationServiceServer) Update(context.Context, *UpdateAplicationStatus) (*UpdateAplicationStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedAplicationServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedAplicationServiceServer) Get(context.Context, *Id) (*Aplication, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedAplicationServiceServer) Find(context.Context, *GetListFilter) (*AplicationList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedAplicationServiceServer) AplicationVerify(context.Context, *AplicationStatus) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AplicationVerify not implemented")
}
func (UnimplementedAplicationServiceServer) VerifyAplicationEmail(context.Context, *VerifyEmail) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyAplicationEmail not implemented")
}
func (UnimplementedAplicationServiceServer) mustEmbedUnimplementedAplicationServiceServer() {}

// UnsafeAplicationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AplicationServiceServer will
// result in compilation errors.
type UnsafeAplicationServiceServer interface {
	mustEmbedUnimplementedAplicationServiceServer()
}

func RegisterAplicationServiceServer(s grpc.ServiceRegistrar, srv AplicationServiceServer) {
	s.RegisterService(&AplicationService_ServiceDesc, srv)
}

func _AplicationService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Aplication)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AplicationServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AplicationService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AplicationServiceServer).Create(ctx, req.(*Aplication))
	}
	return interceptor(ctx, in, info, handler)
}

func _AplicationService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAplicationStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AplicationServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AplicationService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AplicationServiceServer).Update(ctx, req.(*UpdateAplicationStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _AplicationService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AplicationServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AplicationService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AplicationServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AplicationService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AplicationServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AplicationService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AplicationServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AplicationService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AplicationServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AplicationService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AplicationServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AplicationService_AplicationVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AplicationStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AplicationServiceServer).AplicationVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AplicationService_AplicationVerify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AplicationServiceServer).AplicationVerify(ctx, req.(*AplicationStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _AplicationService_VerifyAplicationEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyEmail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AplicationServiceServer).VerifyAplicationEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AplicationService_VerifyAplicationEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AplicationServiceServer).VerifyAplicationEmail(ctx, req.(*VerifyEmail))
	}
	return interceptor(ctx, in, info, handler)
}

// AplicationService_ServiceDesc is the grpc.ServiceDesc for AplicationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AplicationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.AplicationService",
	HandlerType: (*AplicationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _AplicationService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _AplicationService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _AplicationService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _AplicationService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _AplicationService_Find_Handler,
		},
		{
			MethodName: "AplicationVerify",
			Handler:    _AplicationService_AplicationVerify_Handler,
		},
		{
			MethodName: "VerifyAplicationEmail",
			Handler:    _AplicationService_VerifyAplicationEmail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	BrokerService_Create_FullMethodName         = "/company_service.BrokerService/Create"
	BrokerService_Update_FullMethodName         = "/company_service.BrokerService/Update"
	BrokerService_Get_FullMethodName            = "/company_service.BrokerService/Get"
	BrokerService_Find_FullMethodName           = "/company_service.BrokerService/Find"
	BrokerService_UpdateStatus_FullMethodName   = "/company_service.BrokerService/UpdateStatus"
	BrokerService_ReactiveBroker_FullMethodName = "/company_service.BrokerService/ReactiveBroker"
)

// BrokerServiceClient is the client API for BrokerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BrokerServiceClient interface {
	Create(ctx context.Context, in *Broker, opts ...grpc.CallOption) (*Broker, error)
	Update(ctx context.Context, in *Broker, opts ...grpc.CallOption) (*Broker, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Broker, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*BrokerList, error)
	UpdateStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*Empty, error)
	ReactiveBroker(ctx context.Context, in *ReactivatStatus, opts ...grpc.CallOption) (*ReactivatStatus, error)
}

type brokerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBrokerServiceClient(cc grpc.ClientConnInterface) BrokerServiceClient {
	return &brokerServiceClient{cc}
}

func (c *brokerServiceClient) Create(ctx context.Context, in *Broker, opts ...grpc.CallOption) (*Broker, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Broker)
	err := c.cc.Invoke(ctx, BrokerService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) Update(ctx context.Context, in *Broker, opts ...grpc.CallOption) (*Broker, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Broker)
	err := c.cc.Invoke(ctx, BrokerService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Broker, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Broker)
	err := c.cc.Invoke(ctx, BrokerService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*BrokerList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BrokerList)
	err := c.cc.Invoke(ctx, BrokerService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) UpdateStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, BrokerService_UpdateStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) ReactiveBroker(ctx context.Context, in *ReactivatStatus, opts ...grpc.CallOption) (*ReactivatStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReactivatStatus)
	err := c.cc.Invoke(ctx, BrokerService_ReactiveBroker_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BrokerServiceServer is the server API for BrokerService service.
// All implementations must embed UnimplementedBrokerServiceServer
// for forward compatibility
type BrokerServiceServer interface {
	Create(context.Context, *Broker) (*Broker, error)
	Update(context.Context, *Broker) (*Broker, error)
	Get(context.Context, *Id) (*Broker, error)
	Find(context.Context, *GetListFilter) (*BrokerList, error)
	UpdateStatus(context.Context, *UpdateStatusRequest) (*Empty, error)
	ReactiveBroker(context.Context, *ReactivatStatus) (*ReactivatStatus, error)
	mustEmbedUnimplementedBrokerServiceServer()
}

// UnimplementedBrokerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBrokerServiceServer struct {
}

func (UnimplementedBrokerServiceServer) Create(context.Context, *Broker) (*Broker, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedBrokerServiceServer) Update(context.Context, *Broker) (*Broker, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedBrokerServiceServer) Get(context.Context, *Id) (*Broker, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedBrokerServiceServer) Find(context.Context, *GetListFilter) (*BrokerList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedBrokerServiceServer) UpdateStatus(context.Context, *UpdateStatusRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStatus not implemented")
}
func (UnimplementedBrokerServiceServer) ReactiveBroker(context.Context, *ReactivatStatus) (*ReactivatStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReactiveBroker not implemented")
}
func (UnimplementedBrokerServiceServer) mustEmbedUnimplementedBrokerServiceServer() {}

// UnsafeBrokerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BrokerServiceServer will
// result in compilation errors.
type UnsafeBrokerServiceServer interface {
	mustEmbedUnimplementedBrokerServiceServer()
}

func RegisterBrokerServiceServer(s grpc.ServiceRegistrar, srv BrokerServiceServer) {
	s.RegisterService(&BrokerService_ServiceDesc, srv)
}

func _BrokerService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Broker)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BrokerService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).Create(ctx, req.(*Broker))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Broker)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BrokerService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).Update(ctx, req.(*Broker))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BrokerService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BrokerService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BrokerService_UpdateStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).UpdateStatus(ctx, req.(*UpdateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_ReactiveBroker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReactivatStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).ReactiveBroker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BrokerService_ReactiveBroker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).ReactiveBroker(ctx, req.(*ReactivatStatus))
	}
	return interceptor(ctx, in, info, handler)
}

// BrokerService_ServiceDesc is the grpc.ServiceDesc for BrokerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BrokerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.BrokerService",
	HandlerType: (*BrokerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _BrokerService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _BrokerService_Update_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _BrokerService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _BrokerService_Find_Handler,
		},
		{
			MethodName: "UpdateStatus",
			Handler:    _BrokerService_UpdateStatus_Handler,
		},
		{
			MethodName: "ReactiveBroker",
			Handler:    _BrokerService_ReactiveBroker_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	LocationService_Create_FullMethodName           = "/company_service.LocationService/Create"
	LocationService_Update_FullMethodName           = "/company_service.LocationService/Update"
	LocationService_Get_FullMethodName              = "/company_service.LocationService/Get"
	LocationService_Find_FullMethodName             = "/company_service.LocationService/Find"
	LocationService_UpdateStatus_FullMethodName     = "/company_service.LocationService/UpdateStatus"
	LocationService_ReactiveLocation_FullMethodName = "/company_service.LocationService/ReactiveLocation"
)

// LocationServiceClient is the client API for LocationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LocationServiceClient interface {
	Create(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Location, error)
	Update(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Location, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Location, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*LocationList, error)
	UpdateStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*Empty, error)
	ReactiveLocation(ctx context.Context, in *ReactiveStatus, opts ...grpc.CallOption) (*ReactiveStatus, error)
}

type locationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLocationServiceClient(cc grpc.ClientConnInterface) LocationServiceClient {
	return &locationServiceClient{cc}
}

func (c *locationServiceClient) Create(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Location, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Location)
	err := c.cc.Invoke(ctx, LocationService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) Update(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Location, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Location)
	err := c.cc.Invoke(ctx, LocationService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Location, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Location)
	err := c.cc.Invoke(ctx, LocationService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*LocationList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LocationList)
	err := c.cc.Invoke(ctx, LocationService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) UpdateStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LocationService_UpdateStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) ReactiveLocation(ctx context.Context, in *ReactiveStatus, opts ...grpc.CallOption) (*ReactiveStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReactiveStatus)
	err := c.cc.Invoke(ctx, LocationService_ReactiveLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LocationServiceServer is the server API for LocationService service.
// All implementations must embed UnimplementedLocationServiceServer
// for forward compatibility
type LocationServiceServer interface {
	Create(context.Context, *Location) (*Location, error)
	Update(context.Context, *Location) (*Location, error)
	Get(context.Context, *Id) (*Location, error)
	Find(context.Context, *GetListFilter) (*LocationList, error)
	UpdateStatus(context.Context, *UpdateStatusRequest) (*Empty, error)
	ReactiveLocation(context.Context, *ReactiveStatus) (*ReactiveStatus, error)
	mustEmbedUnimplementedLocationServiceServer()
}

// UnimplementedLocationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLocationServiceServer struct {
}

func (UnimplementedLocationServiceServer) Create(context.Context, *Location) (*Location, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedLocationServiceServer) Update(context.Context, *Location) (*Location, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedLocationServiceServer) Get(context.Context, *Id) (*Location, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedLocationServiceServer) Find(context.Context, *GetListFilter) (*LocationList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedLocationServiceServer) UpdateStatus(context.Context, *UpdateStatusRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStatus not implemented")
}
func (UnimplementedLocationServiceServer) ReactiveLocation(context.Context, *ReactiveStatus) (*ReactiveStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReactiveLocation not implemented")
}
func (UnimplementedLocationServiceServer) mustEmbedUnimplementedLocationServiceServer() {}

// UnsafeLocationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LocationServiceServer will
// result in compilation errors.
type UnsafeLocationServiceServer interface {
	mustEmbedUnimplementedLocationServiceServer()
}

func RegisterLocationServiceServer(s grpc.ServiceRegistrar, srv LocationServiceServer) {
	s.RegisterService(&LocationService_ServiceDesc, srv)
}

func _LocationService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).Create(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).Update(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_UpdateStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).UpdateStatus(ctx, req.(*UpdateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_ReactiveLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReactiveStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).ReactiveLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_ReactiveLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).ReactiveLocation(ctx, req.(*ReactiveStatus))
	}
	return interceptor(ctx, in, info, handler)
}

// LocationService_ServiceDesc is the grpc.ServiceDesc for LocationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LocationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.LocationService",
	HandlerType: (*LocationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _LocationService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _LocationService_Update_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _LocationService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _LocationService_Find_Handler,
		},
		{
			MethodName: "UpdateStatus",
			Handler:    _LocationService_UpdateStatus_Handler,
		},
		{
			MethodName: "ReactiveLocation",
			Handler:    _LocationService_ReactiveLocation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	DocumentTypeService_Create_FullMethodName = "/company_service.DocumentTypeService/Create"
	DocumentTypeService_Update_FullMethodName = "/company_service.DocumentTypeService/Update"
	DocumentTypeService_Delete_FullMethodName = "/company_service.DocumentTypeService/Delete"
	DocumentTypeService_Get_FullMethodName    = "/company_service.DocumentTypeService/Get"
	DocumentTypeService_Find_FullMethodName   = "/company_service.DocumentTypeService/Find"
)

// DocumentTypeServiceClient is the client API for DocumentTypeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DocumentTypeServiceClient interface {
	Create(ctx context.Context, in *DocumentType, opts ...grpc.CallOption) (*DocumentType, error)
	Update(ctx context.Context, in *DocumentType, opts ...grpc.CallOption) (*DocumentType, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*DocumentType, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*DocumentTypeList, error)
}

type documentTypeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDocumentTypeServiceClient(cc grpc.ClientConnInterface) DocumentTypeServiceClient {
	return &documentTypeServiceClient{cc}
}

func (c *documentTypeServiceClient) Create(ctx context.Context, in *DocumentType, opts ...grpc.CallOption) (*DocumentType, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DocumentType)
	err := c.cc.Invoke(ctx, DocumentTypeService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentTypeServiceClient) Update(ctx context.Context, in *DocumentType, opts ...grpc.CallOption) (*DocumentType, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DocumentType)
	err := c.cc.Invoke(ctx, DocumentTypeService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentTypeServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, DocumentTypeService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentTypeServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*DocumentType, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DocumentType)
	err := c.cc.Invoke(ctx, DocumentTypeService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentTypeServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*DocumentTypeList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DocumentTypeList)
	err := c.cc.Invoke(ctx, DocumentTypeService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DocumentTypeServiceServer is the server API for DocumentTypeService service.
// All implementations must embed UnimplementedDocumentTypeServiceServer
// for forward compatibility
type DocumentTypeServiceServer interface {
	Create(context.Context, *DocumentType) (*DocumentType, error)
	Update(context.Context, *DocumentType) (*DocumentType, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*DocumentType, error)
	Find(context.Context, *GetListFilter) (*DocumentTypeList, error)
	mustEmbedUnimplementedDocumentTypeServiceServer()
}

// UnimplementedDocumentTypeServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDocumentTypeServiceServer struct {
}

func (UnimplementedDocumentTypeServiceServer) Create(context.Context, *DocumentType) (*DocumentType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedDocumentTypeServiceServer) Update(context.Context, *DocumentType) (*DocumentType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedDocumentTypeServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedDocumentTypeServiceServer) Get(context.Context, *Id) (*DocumentType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDocumentTypeServiceServer) Find(context.Context, *GetListFilter) (*DocumentTypeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedDocumentTypeServiceServer) mustEmbedUnimplementedDocumentTypeServiceServer() {}

// UnsafeDocumentTypeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DocumentTypeServiceServer will
// result in compilation errors.
type UnsafeDocumentTypeServiceServer interface {
	mustEmbedUnimplementedDocumentTypeServiceServer()
}

func RegisterDocumentTypeServiceServer(s grpc.ServiceRegistrar, srv DocumentTypeServiceServer) {
	s.RegisterService(&DocumentTypeService_ServiceDesc, srv)
}

func _DocumentTypeService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentType)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentTypeServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocumentTypeService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentTypeServiceServer).Create(ctx, req.(*DocumentType))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentTypeService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentType)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentTypeServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocumentTypeService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentTypeServiceServer).Update(ctx, req.(*DocumentType))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentTypeService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentTypeServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocumentTypeService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentTypeServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentTypeService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentTypeServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocumentTypeService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentTypeServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentTypeService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentTypeServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocumentTypeService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentTypeServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// DocumentTypeService_ServiceDesc is the grpc.ServiceDesc for DocumentTypeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DocumentTypeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.DocumentTypeService",
	HandlerType: (*DocumentTypeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _DocumentTypeService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _DocumentTypeService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _DocumentTypeService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DocumentTypeService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _DocumentTypeService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	DocumentService_Create_FullMethodName = "/company_service.DocumentService/Create"
	DocumentService_Update_FullMethodName = "/company_service.DocumentService/Update"
	DocumentService_Delete_FullMethodName = "/company_service.DocumentService/Delete"
	DocumentService_Get_FullMethodName    = "/company_service.DocumentService/Get"
	DocumentService_Find_FullMethodName   = "/company_service.DocumentService/Find"
)

// DocumentServiceClient is the client API for DocumentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DocumentServiceClient interface {
	Create(ctx context.Context, in *Document, opts ...grpc.CallOption) (*Document, error)
	Update(ctx context.Context, in *Document, opts ...grpc.CallOption) (*Document, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Document, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*DocumentList, error)
}

type documentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDocumentServiceClient(cc grpc.ClientConnInterface) DocumentServiceClient {
	return &documentServiceClient{cc}
}

func (c *documentServiceClient) Create(ctx context.Context, in *Document, opts ...grpc.CallOption) (*Document, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Document)
	err := c.cc.Invoke(ctx, DocumentService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) Update(ctx context.Context, in *Document, opts ...grpc.CallOption) (*Document, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Document)
	err := c.cc.Invoke(ctx, DocumentService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, DocumentService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Document, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Document)
	err := c.cc.Invoke(ctx, DocumentService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*DocumentList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DocumentList)
	err := c.cc.Invoke(ctx, DocumentService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DocumentServiceServer is the server API for DocumentService service.
// All implementations must embed UnimplementedDocumentServiceServer
// for forward compatibility
type DocumentServiceServer interface {
	Create(context.Context, *Document) (*Document, error)
	Update(context.Context, *Document) (*Document, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*Document, error)
	Find(context.Context, *GetListFilter) (*DocumentList, error)
	mustEmbedUnimplementedDocumentServiceServer()
}

// UnimplementedDocumentServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDocumentServiceServer struct {
}

func (UnimplementedDocumentServiceServer) Create(context.Context, *Document) (*Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedDocumentServiceServer) Update(context.Context, *Document) (*Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedDocumentServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedDocumentServiceServer) Get(context.Context, *Id) (*Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDocumentServiceServer) Find(context.Context, *GetListFilter) (*DocumentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedDocumentServiceServer) mustEmbedUnimplementedDocumentServiceServer() {}

// UnsafeDocumentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DocumentServiceServer will
// result in compilation errors.
type UnsafeDocumentServiceServer interface {
	mustEmbedUnimplementedDocumentServiceServer()
}

func RegisterDocumentServiceServer(s grpc.ServiceRegistrar, srv DocumentServiceServer) {
	s.RegisterService(&DocumentService_ServiceDesc, srv)
}

func _DocumentService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Document)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocumentService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).Create(ctx, req.(*Document))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Document)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocumentService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).Update(ctx, req.(*Document))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocumentService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocumentService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocumentService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// DocumentService_ServiceDesc is the grpc.ServiceDesc for DocumentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DocumentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.DocumentService",
	HandlerType: (*DocumentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _DocumentService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _DocumentService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _DocumentService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DocumentService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _DocumentService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	TagService_Create_FullMethodName = "/company_service.TagService/Create"
	TagService_Update_FullMethodName = "/company_service.TagService/Update"
	TagService_Delete_FullMethodName = "/company_service.TagService/Delete"
	TagService_Get_FullMethodName    = "/company_service.TagService/Get"
	TagService_Find_FullMethodName   = "/company_service.TagService/Find"
)

// TagServiceClient is the client API for TagService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagServiceClient interface {
	Create(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*Tag, error)
	Update(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*Tag, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Tag, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*TagList, error)
}

type tagServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTagServiceClient(cc grpc.ClientConnInterface) TagServiceClient {
	return &tagServiceClient{cc}
}

func (c *tagServiceClient) Create(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*Tag, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tag)
	err := c.cc.Invoke(ctx, TagService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) Update(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*Tag, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tag)
	err := c.cc.Invoke(ctx, TagService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TagService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Tag, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tag)
	err := c.cc.Invoke(ctx, TagService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*TagList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TagList)
	err := c.cc.Invoke(ctx, TagService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagServiceServer is the server API for TagService service.
// All implementations must embed UnimplementedTagServiceServer
// for forward compatibility
type TagServiceServer interface {
	Create(context.Context, *Tag) (*Tag, error)
	Update(context.Context, *Tag) (*Tag, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*Tag, error)
	Find(context.Context, *GetListFilter) (*TagList, error)
	mustEmbedUnimplementedTagServiceServer()
}

// UnimplementedTagServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTagServiceServer struct {
}

func (UnimplementedTagServiceServer) Create(context.Context, *Tag) (*Tag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedTagServiceServer) Update(context.Context, *Tag) (*Tag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedTagServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTagServiceServer) Get(context.Context, *Id) (*Tag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTagServiceServer) Find(context.Context, *GetListFilter) (*TagList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedTagServiceServer) mustEmbedUnimplementedTagServiceServer() {}

// UnsafeTagServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagServiceServer will
// result in compilation errors.
type UnsafeTagServiceServer interface {
	mustEmbedUnimplementedTagServiceServer()
}

func RegisterTagServiceServer(s grpc.ServiceRegistrar, srv TagServiceServer) {
	s.RegisterService(&TagService_ServiceDesc, srv)
}

func _TagService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).Create(ctx, req.(*Tag))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).Update(ctx, req.(*Tag))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// TagService_ServiceDesc is the grpc.ServiceDesc for TagService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.TagService",
	HandlerType: (*TagServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _TagService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _TagService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TagService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TagService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _TagService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	LoadService_Create_FullMethodName      = "/company_service.LoadService/Create"
	LoadService_Find_FullMethodName        = "/company_service.LoadService/Find"
	LoadService_Get_FullMethodName         = "/company_service.LoadService/Get"
	LoadService_UpdateField_FullMethodName = "/company_service.LoadService/UpdateField"
	LoadService_Update_FullMethodName      = "/company_service.LoadService/Update"
	LoadService_Delete_FullMethodName      = "/company_service.LoadService/Delete"
	LoadService_Upload_FullMethodName      = "/company_service.LoadService/Upload"
)

// LoadServiceClient is the client API for LoadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoadServiceClient interface {
	Create(ctx context.Context, in *LoadCreateRequest, opts ...grpc.CallOption) (*LoadCreateResponse, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*LoadGetListResponse, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoadGetResponse, error)
	UpdateField(ctx context.Context, in *UpdateFieldRequest, opts ...grpc.CallOption) (*Empty, error)
	Update(ctx context.Context, in *LoadGetResponse, opts ...grpc.CallOption) (*LoadGetResponse, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Upload(ctx context.Context, in *UploadLoad, opts ...grpc.CallOption) (*Empty, error)
}

type loadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLoadServiceClient(cc grpc.ClientConnInterface) LoadServiceClient {
	return &loadServiceClient{cc}
}

func (c *loadServiceClient) Create(ctx context.Context, in *LoadCreateRequest, opts ...grpc.CallOption) (*LoadCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadCreateResponse)
	err := c.cc.Invoke(ctx, LoadService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*LoadGetListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadGetListResponse)
	err := c.cc.Invoke(ctx, LoadService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoadGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadGetResponse)
	err := c.cc.Invoke(ctx, LoadService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadServiceClient) UpdateField(ctx context.Context, in *UpdateFieldRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LoadService_UpdateField_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadServiceClient) Update(ctx context.Context, in *LoadGetResponse, opts ...grpc.CallOption) (*LoadGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadGetResponse)
	err := c.cc.Invoke(ctx, LoadService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LoadService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadServiceClient) Upload(ctx context.Context, in *UploadLoad, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LoadService_Upload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoadServiceServer is the server API for LoadService service.
// All implementations must embed UnimplementedLoadServiceServer
// for forward compatibility
type LoadServiceServer interface {
	Create(context.Context, *LoadCreateRequest) (*LoadCreateResponse, error)
	Find(context.Context, *GetListFilter) (*LoadGetListResponse, error)
	Get(context.Context, *Id) (*LoadGetResponse, error)
	UpdateField(context.Context, *UpdateFieldRequest) (*Empty, error)
	Update(context.Context, *LoadGetResponse) (*LoadGetResponse, error)
	Delete(context.Context, *Id) (*Empty, error)
	Upload(context.Context, *UploadLoad) (*Empty, error)
	mustEmbedUnimplementedLoadServiceServer()
}

// UnimplementedLoadServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLoadServiceServer struct {
}

func (UnimplementedLoadServiceServer) Create(context.Context, *LoadCreateRequest) (*LoadCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedLoadServiceServer) Find(context.Context, *GetListFilter) (*LoadGetListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedLoadServiceServer) Get(context.Context, *Id) (*LoadGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedLoadServiceServer) UpdateField(context.Context, *UpdateFieldRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateField not implemented")
}
func (UnimplementedLoadServiceServer) Update(context.Context, *LoadGetResponse) (*LoadGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedLoadServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedLoadServiceServer) Upload(context.Context, *UploadLoad) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upload not implemented")
}
func (UnimplementedLoadServiceServer) mustEmbedUnimplementedLoadServiceServer() {}

// UnsafeLoadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoadServiceServer will
// result in compilation errors.
type UnsafeLoadServiceServer interface {
	mustEmbedUnimplementedLoadServiceServer()
}

func RegisterLoadServiceServer(s grpc.ServiceRegistrar, srv LoadServiceServer) {
	s.RegisterService(&LoadService_ServiceDesc, srv)
}

func _LoadService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadServiceServer).Create(ctx, req.(*LoadCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadService_UpdateField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFieldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadServiceServer).UpdateField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadService_UpdateField_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadServiceServer).UpdateField(ctx, req.(*UpdateFieldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadGetResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadServiceServer).Update(ctx, req.(*LoadGetResponse))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadService_Upload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadLoad)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadServiceServer).Upload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadService_Upload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadServiceServer).Upload(ctx, req.(*UploadLoad))
	}
	return interceptor(ctx, in, info, handler)
}

// LoadService_ServiceDesc is the grpc.ServiceDesc for LoadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.LoadService",
	HandlerType: (*LoadServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _LoadService_Create_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _LoadService_Find_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _LoadService_Get_Handler,
		},
		{
			MethodName: "UpdateField",
			Handler:    _LoadService_UpdateField_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _LoadService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _LoadService_Delete_Handler,
		},
		{
			MethodName: "Upload",
			Handler:    _LoadService_Upload_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	LoadPaymentService_Update_FullMethodName = "/company_service.LoadPaymentService/Update"
	LoadPaymentService_Get_FullMethodName    = "/company_service.LoadPaymentService/Get"
)

// LoadPaymentServiceClient is the client API for LoadPaymentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoadPaymentServiceClient interface {
	Update(ctx context.Context, in *LoadPayment, opts ...grpc.CallOption) (*LoadPayment, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoadPayment, error)
}

type loadPaymentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLoadPaymentServiceClient(cc grpc.ClientConnInterface) LoadPaymentServiceClient {
	return &loadPaymentServiceClient{cc}
}

func (c *loadPaymentServiceClient) Update(ctx context.Context, in *LoadPayment, opts ...grpc.CallOption) (*LoadPayment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadPayment)
	err := c.cc.Invoke(ctx, LoadPaymentService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadPaymentServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoadPayment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadPayment)
	err := c.cc.Invoke(ctx, LoadPaymentService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoadPaymentServiceServer is the server API for LoadPaymentService service.
// All implementations must embed UnimplementedLoadPaymentServiceServer
// for forward compatibility
type LoadPaymentServiceServer interface {
	Update(context.Context, *LoadPayment) (*LoadPayment, error)
	Get(context.Context, *Id) (*LoadPayment, error)
	mustEmbedUnimplementedLoadPaymentServiceServer()
}

// UnimplementedLoadPaymentServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLoadPaymentServiceServer struct {
}

func (UnimplementedLoadPaymentServiceServer) Update(context.Context, *LoadPayment) (*LoadPayment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedLoadPaymentServiceServer) Get(context.Context, *Id) (*LoadPayment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedLoadPaymentServiceServer) mustEmbedUnimplementedLoadPaymentServiceServer() {}

// UnsafeLoadPaymentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoadPaymentServiceServer will
// result in compilation errors.
type UnsafeLoadPaymentServiceServer interface {
	mustEmbedUnimplementedLoadPaymentServiceServer()
}

func RegisterLoadPaymentServiceServer(s grpc.ServiceRegistrar, srv LoadPaymentServiceServer) {
	s.RegisterService(&LoadPaymentService_ServiceDesc, srv)
}

func _LoadPaymentService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadPayment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadPaymentServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadPaymentService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadPaymentServiceServer).Update(ctx, req.(*LoadPayment))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadPaymentService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadPaymentServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadPaymentService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadPaymentServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// LoadPaymentService_ServiceDesc is the grpc.ServiceDesc for LoadPaymentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoadPaymentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.LoadPaymentService",
	HandlerType: (*LoadPaymentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Update",
			Handler:    _LoadPaymentService_Update_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _LoadPaymentService_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	LoadAttachmentService_Create_FullMethodName = "/company_service.LoadAttachmentService/Create"
	LoadAttachmentService_Update_FullMethodName = "/company_service.LoadAttachmentService/Update"
	LoadAttachmentService_Delete_FullMethodName = "/company_service.LoadAttachmentService/Delete"
	LoadAttachmentService_Get_FullMethodName    = "/company_service.LoadAttachmentService/Get"
	LoadAttachmentService_Find_FullMethodName   = "/company_service.LoadAttachmentService/Find"
)

// LoadAttachmentServiceClient is the client API for LoadAttachmentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoadAttachmentServiceClient interface {
	Create(ctx context.Context, in *LoadAttachment, opts ...grpc.CallOption) (*LoadAttachment, error)
	Update(ctx context.Context, in *LoadAttachment, opts ...grpc.CallOption) (*LoadAttachment, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoadAttachment, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*LoadAttachmentList, error)
}

type loadAttachmentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLoadAttachmentServiceClient(cc grpc.ClientConnInterface) LoadAttachmentServiceClient {
	return &loadAttachmentServiceClient{cc}
}

func (c *loadAttachmentServiceClient) Create(ctx context.Context, in *LoadAttachment, opts ...grpc.CallOption) (*LoadAttachment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadAttachment)
	err := c.cc.Invoke(ctx, LoadAttachmentService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadAttachmentServiceClient) Update(ctx context.Context, in *LoadAttachment, opts ...grpc.CallOption) (*LoadAttachment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadAttachment)
	err := c.cc.Invoke(ctx, LoadAttachmentService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadAttachmentServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LoadAttachmentService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadAttachmentServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoadAttachment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadAttachment)
	err := c.cc.Invoke(ctx, LoadAttachmentService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadAttachmentServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*LoadAttachmentList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadAttachmentList)
	err := c.cc.Invoke(ctx, LoadAttachmentService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoadAttachmentServiceServer is the server API for LoadAttachmentService service.
// All implementations must embed UnimplementedLoadAttachmentServiceServer
// for forward compatibility
type LoadAttachmentServiceServer interface {
	Create(context.Context, *LoadAttachment) (*LoadAttachment, error)
	Update(context.Context, *LoadAttachment) (*LoadAttachment, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*LoadAttachment, error)
	Find(context.Context, *GetListFilter) (*LoadAttachmentList, error)
	mustEmbedUnimplementedLoadAttachmentServiceServer()
}

// UnimplementedLoadAttachmentServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLoadAttachmentServiceServer struct {
}

func (UnimplementedLoadAttachmentServiceServer) Create(context.Context, *LoadAttachment) (*LoadAttachment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedLoadAttachmentServiceServer) Update(context.Context, *LoadAttachment) (*LoadAttachment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedLoadAttachmentServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedLoadAttachmentServiceServer) Get(context.Context, *Id) (*LoadAttachment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedLoadAttachmentServiceServer) Find(context.Context, *GetListFilter) (*LoadAttachmentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedLoadAttachmentServiceServer) mustEmbedUnimplementedLoadAttachmentServiceServer() {}

// UnsafeLoadAttachmentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoadAttachmentServiceServer will
// result in compilation errors.
type UnsafeLoadAttachmentServiceServer interface {
	mustEmbedUnimplementedLoadAttachmentServiceServer()
}

func RegisterLoadAttachmentServiceServer(s grpc.ServiceRegistrar, srv LoadAttachmentServiceServer) {
	s.RegisterService(&LoadAttachmentService_ServiceDesc, srv)
}

func _LoadAttachmentService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadAttachment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadAttachmentServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadAttachmentService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadAttachmentServiceServer).Create(ctx, req.(*LoadAttachment))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadAttachmentService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadAttachment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadAttachmentServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadAttachmentService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadAttachmentServiceServer).Update(ctx, req.(*LoadAttachment))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadAttachmentService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadAttachmentServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadAttachmentService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadAttachmentServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadAttachmentService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadAttachmentServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadAttachmentService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadAttachmentServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadAttachmentService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadAttachmentServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadAttachmentService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadAttachmentServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// LoadAttachmentService_ServiceDesc is the grpc.ServiceDesc for LoadAttachmentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoadAttachmentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.LoadAttachmentService",
	HandlerType: (*LoadAttachmentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _LoadAttachmentService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _LoadAttachmentService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _LoadAttachmentService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _LoadAttachmentService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _LoadAttachmentService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	NoteStatusesService_Create_FullMethodName = "/company_service.NoteStatusesService/Create"
	NoteStatusesService_Update_FullMethodName = "/company_service.NoteStatusesService/Update"
	NoteStatusesService_Delete_FullMethodName = "/company_service.NoteStatusesService/Delete"
	NoteStatusesService_Get_FullMethodName    = "/company_service.NoteStatusesService/Get"
	NoteStatusesService_Find_FullMethodName   = "/company_service.NoteStatusesService/Find"
)

// NoteStatusesServiceClient is the client API for NoteStatusesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NoteStatusesServiceClient interface {
	Create(ctx context.Context, in *NoteStatuses, opts ...grpc.CallOption) (*NoteStatuses, error)
	Update(ctx context.Context, in *NoteStatuses, opts ...grpc.CallOption) (*NoteStatuses, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*NoteStatuses, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*NoteStatusesList, error)
}

type noteStatusesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNoteStatusesServiceClient(cc grpc.ClientConnInterface) NoteStatusesServiceClient {
	return &noteStatusesServiceClient{cc}
}

func (c *noteStatusesServiceClient) Create(ctx context.Context, in *NoteStatuses, opts ...grpc.CallOption) (*NoteStatuses, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NoteStatuses)
	err := c.cc.Invoke(ctx, NoteStatusesService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noteStatusesServiceClient) Update(ctx context.Context, in *NoteStatuses, opts ...grpc.CallOption) (*NoteStatuses, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NoteStatuses)
	err := c.cc.Invoke(ctx, NoteStatusesService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noteStatusesServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, NoteStatusesService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noteStatusesServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*NoteStatuses, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NoteStatuses)
	err := c.cc.Invoke(ctx, NoteStatusesService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noteStatusesServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*NoteStatusesList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NoteStatusesList)
	err := c.cc.Invoke(ctx, NoteStatusesService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NoteStatusesServiceServer is the server API for NoteStatusesService service.
// All implementations must embed UnimplementedNoteStatusesServiceServer
// for forward compatibility
type NoteStatusesServiceServer interface {
	Create(context.Context, *NoteStatuses) (*NoteStatuses, error)
	Update(context.Context, *NoteStatuses) (*NoteStatuses, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*NoteStatuses, error)
	Find(context.Context, *GetListFilter) (*NoteStatusesList, error)
	mustEmbedUnimplementedNoteStatusesServiceServer()
}

// UnimplementedNoteStatusesServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNoteStatusesServiceServer struct {
}

func (UnimplementedNoteStatusesServiceServer) Create(context.Context, *NoteStatuses) (*NoteStatuses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedNoteStatusesServiceServer) Update(context.Context, *NoteStatuses) (*NoteStatuses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedNoteStatusesServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedNoteStatusesServiceServer) Get(context.Context, *Id) (*NoteStatuses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedNoteStatusesServiceServer) Find(context.Context, *GetListFilter) (*NoteStatusesList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedNoteStatusesServiceServer) mustEmbedUnimplementedNoteStatusesServiceServer() {}

// UnsafeNoteStatusesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NoteStatusesServiceServer will
// result in compilation errors.
type UnsafeNoteStatusesServiceServer interface {
	mustEmbedUnimplementedNoteStatusesServiceServer()
}

func RegisterNoteStatusesServiceServer(s grpc.ServiceRegistrar, srv NoteStatusesServiceServer) {
	s.RegisterService(&NoteStatusesService_ServiceDesc, srv)
}

func _NoteStatusesService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoteStatuses)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteStatusesServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NoteStatusesService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteStatusesServiceServer).Create(ctx, req.(*NoteStatuses))
	}
	return interceptor(ctx, in, info, handler)
}

func _NoteStatusesService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoteStatuses)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteStatusesServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NoteStatusesService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteStatusesServiceServer).Update(ctx, req.(*NoteStatuses))
	}
	return interceptor(ctx, in, info, handler)
}

func _NoteStatusesService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteStatusesServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NoteStatusesService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteStatusesServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _NoteStatusesService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteStatusesServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NoteStatusesService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteStatusesServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _NoteStatusesService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteStatusesServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NoteStatusesService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteStatusesServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// NoteStatusesService_ServiceDesc is the grpc.ServiceDesc for NoteStatusesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NoteStatusesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.NoteStatusesService",
	HandlerType: (*NoteStatusesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _NoteStatusesService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _NoteStatusesService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _NoteStatusesService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _NoteStatusesService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _NoteStatusesService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	LoadNoteService_Create_FullMethodName = "/company_service.LoadNoteService/Create"
	LoadNoteService_Update_FullMethodName = "/company_service.LoadNoteService/Update"
	LoadNoteService_Delete_FullMethodName = "/company_service.LoadNoteService/Delete"
	LoadNoteService_Get_FullMethodName    = "/company_service.LoadNoteService/Get"
	LoadNoteService_Find_FullMethodName   = "/company_service.LoadNoteService/Find"
)

// LoadNoteServiceClient is the client API for LoadNoteService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoadNoteServiceClient interface {
	Create(ctx context.Context, in *LoadNote, opts ...grpc.CallOption) (*LoadNote, error)
	Update(ctx context.Context, in *LoadNote, opts ...grpc.CallOption) (*LoadNote, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoadNote, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*LoadNoteList, error)
}

type loadNoteServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLoadNoteServiceClient(cc grpc.ClientConnInterface) LoadNoteServiceClient {
	return &loadNoteServiceClient{cc}
}

func (c *loadNoteServiceClient) Create(ctx context.Context, in *LoadNote, opts ...grpc.CallOption) (*LoadNote, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadNote)
	err := c.cc.Invoke(ctx, LoadNoteService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadNoteServiceClient) Update(ctx context.Context, in *LoadNote, opts ...grpc.CallOption) (*LoadNote, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadNote)
	err := c.cc.Invoke(ctx, LoadNoteService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadNoteServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LoadNoteService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadNoteServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoadNote, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadNote)
	err := c.cc.Invoke(ctx, LoadNoteService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadNoteServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*LoadNoteList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadNoteList)
	err := c.cc.Invoke(ctx, LoadNoteService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoadNoteServiceServer is the server API for LoadNoteService service.
// All implementations must embed UnimplementedLoadNoteServiceServer
// for forward compatibility
type LoadNoteServiceServer interface {
	Create(context.Context, *LoadNote) (*LoadNote, error)
	Update(context.Context, *LoadNote) (*LoadNote, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*LoadNote, error)
	Find(context.Context, *GetListFilter) (*LoadNoteList, error)
	mustEmbedUnimplementedLoadNoteServiceServer()
}

// UnimplementedLoadNoteServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLoadNoteServiceServer struct {
}

func (UnimplementedLoadNoteServiceServer) Create(context.Context, *LoadNote) (*LoadNote, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedLoadNoteServiceServer) Update(context.Context, *LoadNote) (*LoadNote, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedLoadNoteServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedLoadNoteServiceServer) Get(context.Context, *Id) (*LoadNote, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedLoadNoteServiceServer) Find(context.Context, *GetListFilter) (*LoadNoteList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedLoadNoteServiceServer) mustEmbedUnimplementedLoadNoteServiceServer() {}

// UnsafeLoadNoteServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoadNoteServiceServer will
// result in compilation errors.
type UnsafeLoadNoteServiceServer interface {
	mustEmbedUnimplementedLoadNoteServiceServer()
}

func RegisterLoadNoteServiceServer(s grpc.ServiceRegistrar, srv LoadNoteServiceServer) {
	s.RegisterService(&LoadNoteService_ServiceDesc, srv)
}

func _LoadNoteService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadNote)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadNoteServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadNoteService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadNoteServiceServer).Create(ctx, req.(*LoadNote))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadNoteService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadNote)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadNoteServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadNoteService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadNoteServiceServer).Update(ctx, req.(*LoadNote))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadNoteService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadNoteServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadNoteService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadNoteServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadNoteService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadNoteServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadNoteService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadNoteServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadNoteService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadNoteServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadNoteService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadNoteServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// LoadNoteService_ServiceDesc is the grpc.ServiceDesc for LoadNoteService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoadNoteService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.LoadNoteService",
	HandlerType: (*LoadNoteServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _LoadNoteService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _LoadNoteService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _LoadNoteService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _LoadNoteService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _LoadNoteService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	StopService_Create_FullMethodName = "/company_service.StopService/Create"
	StopService_Update_FullMethodName = "/company_service.StopService/Update"
	StopService_Delete_FullMethodName = "/company_service.StopService/Delete"
	StopService_Get_FullMethodName    = "/company_service.StopService/Get"
	StopService_Find_FullMethodName   = "/company_service.StopService/Find"
)

// StopServiceClient is the client API for StopService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StopServiceClient interface {
	Create(ctx context.Context, in *Stop, opts ...grpc.CallOption) (*Stop, error)
	Update(ctx context.Context, in *Stop, opts ...grpc.CallOption) (*Stop, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Stop, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*StopList, error)
}

type stopServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStopServiceClient(cc grpc.ClientConnInterface) StopServiceClient {
	return &stopServiceClient{cc}
}

func (c *stopServiceClient) Create(ctx context.Context, in *Stop, opts ...grpc.CallOption) (*Stop, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Stop)
	err := c.cc.Invoke(ctx, StopService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stopServiceClient) Update(ctx context.Context, in *Stop, opts ...grpc.CallOption) (*Stop, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Stop)
	err := c.cc.Invoke(ctx, StopService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stopServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, StopService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stopServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Stop, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Stop)
	err := c.cc.Invoke(ctx, StopService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stopServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*StopList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopList)
	err := c.cc.Invoke(ctx, StopService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StopServiceServer is the server API for StopService service.
// All implementations must embed UnimplementedStopServiceServer
// for forward compatibility
type StopServiceServer interface {
	Create(context.Context, *Stop) (*Stop, error)
	Update(context.Context, *Stop) (*Stop, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*Stop, error)
	Find(context.Context, *GetListFilter) (*StopList, error)
	mustEmbedUnimplementedStopServiceServer()
}

// UnimplementedStopServiceServer must be embedded to have forward compatible implementations.
type UnimplementedStopServiceServer struct {
}

func (UnimplementedStopServiceServer) Create(context.Context, *Stop) (*Stop, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedStopServiceServer) Update(context.Context, *Stop) (*Stop, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedStopServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedStopServiceServer) Get(context.Context, *Id) (*Stop, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedStopServiceServer) Find(context.Context, *GetListFilter) (*StopList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedStopServiceServer) mustEmbedUnimplementedStopServiceServer() {}

// UnsafeStopServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StopServiceServer will
// result in compilation errors.
type UnsafeStopServiceServer interface {
	mustEmbedUnimplementedStopServiceServer()
}

func RegisterStopServiceServer(s grpc.ServiceRegistrar, srv StopServiceServer) {
	s.RegisterService(&StopService_ServiceDesc, srv)
}

func _StopService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Stop)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StopServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StopService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StopServiceServer).Create(ctx, req.(*Stop))
	}
	return interceptor(ctx, in, info, handler)
}

func _StopService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Stop)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StopServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StopService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StopServiceServer).Update(ctx, req.(*Stop))
	}
	return interceptor(ctx, in, info, handler)
}

func _StopService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StopServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StopService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StopServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _StopService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StopServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StopService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StopServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _StopService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StopServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StopService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StopServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// StopService_ServiceDesc is the grpc.ServiceDesc for StopService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StopService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.StopService",
	HandlerType: (*StopServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _StopService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _StopService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _StopService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _StopService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _StopService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	ServiceCategoryService_Create_FullMethodName = "/company_service.ServiceCategoryService/Create"
	ServiceCategoryService_Update_FullMethodName = "/company_service.ServiceCategoryService/Update"
	ServiceCategoryService_Delete_FullMethodName = "/company_service.ServiceCategoryService/Delete"
	ServiceCategoryService_Get_FullMethodName    = "/company_service.ServiceCategoryService/Get"
	ServiceCategoryService_Find_FullMethodName   = "/company_service.ServiceCategoryService/Find"
)

// ServiceCategoryServiceClient is the client API for ServiceCategoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServiceCategoryServiceClient interface {
	Create(ctx context.Context, in *ServiceCategory, opts ...grpc.CallOption) (*ServiceCategory, error)
	Update(ctx context.Context, in *ServiceCategory, opts ...grpc.CallOption) (*ServiceCategory, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ServiceCategory, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ServiceCategoryList, error)
}

type serviceCategoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewServiceCategoryServiceClient(cc grpc.ClientConnInterface) ServiceCategoryServiceClient {
	return &serviceCategoryServiceClient{cc}
}

func (c *serviceCategoryServiceClient) Create(ctx context.Context, in *ServiceCategory, opts ...grpc.CallOption) (*ServiceCategory, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServiceCategory)
	err := c.cc.Invoke(ctx, ServiceCategoryService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceCategoryServiceClient) Update(ctx context.Context, in *ServiceCategory, opts ...grpc.CallOption) (*ServiceCategory, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServiceCategory)
	err := c.cc.Invoke(ctx, ServiceCategoryService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceCategoryServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ServiceCategoryService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceCategoryServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ServiceCategory, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServiceCategory)
	err := c.cc.Invoke(ctx, ServiceCategoryService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceCategoryServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ServiceCategoryList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServiceCategoryList)
	err := c.cc.Invoke(ctx, ServiceCategoryService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServiceCategoryServiceServer is the server API for ServiceCategoryService service.
// All implementations must embed UnimplementedServiceCategoryServiceServer
// for forward compatibility
type ServiceCategoryServiceServer interface {
	Create(context.Context, *ServiceCategory) (*ServiceCategory, error)
	Update(context.Context, *ServiceCategory) (*ServiceCategory, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*ServiceCategory, error)
	Find(context.Context, *GetListFilter) (*ServiceCategoryList, error)
	mustEmbedUnimplementedServiceCategoryServiceServer()
}

// UnimplementedServiceCategoryServiceServer must be embedded to have forward compatible implementations.
type UnimplementedServiceCategoryServiceServer struct {
}

func (UnimplementedServiceCategoryServiceServer) Create(context.Context, *ServiceCategory) (*ServiceCategory, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedServiceCategoryServiceServer) Update(context.Context, *ServiceCategory) (*ServiceCategory, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedServiceCategoryServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedServiceCategoryServiceServer) Get(context.Context, *Id) (*ServiceCategory, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedServiceCategoryServiceServer) Find(context.Context, *GetListFilter) (*ServiceCategoryList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedServiceCategoryServiceServer) mustEmbedUnimplementedServiceCategoryServiceServer() {
}

// UnsafeServiceCategoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServiceCategoryServiceServer will
// result in compilation errors.
type UnsafeServiceCategoryServiceServer interface {
	mustEmbedUnimplementedServiceCategoryServiceServer()
}

func RegisterServiceCategoryServiceServer(s grpc.ServiceRegistrar, srv ServiceCategoryServiceServer) {
	s.RegisterService(&ServiceCategoryService_ServiceDesc, srv)
}

func _ServiceCategoryService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceCategory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceCategoryServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceCategoryService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceCategoryServiceServer).Create(ctx, req.(*ServiceCategory))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceCategoryService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceCategory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceCategoryServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceCategoryService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceCategoryServiceServer).Update(ctx, req.(*ServiceCategory))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceCategoryService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceCategoryServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceCategoryService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceCategoryServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceCategoryService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceCategoryServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceCategoryService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceCategoryServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceCategoryService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceCategoryServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceCategoryService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceCategoryServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// ServiceCategoryService_ServiceDesc is the grpc.ServiceDesc for ServiceCategoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ServiceCategoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.ServiceCategoryService",
	HandlerType: (*ServiceCategoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ServiceCategoryService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ServiceCategoryService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ServiceCategoryService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ServiceCategoryService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _ServiceCategoryService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	ServiceService_Create_FullMethodName = "/company_service.ServiceService/Create"
	ServiceService_Update_FullMethodName = "/company_service.ServiceService/Update"
	ServiceService_Delete_FullMethodName = "/company_service.ServiceService/Delete"
	ServiceService_Get_FullMethodName    = "/company_service.ServiceService/Get"
	ServiceService_Find_FullMethodName   = "/company_service.ServiceService/Find"
)

// ServiceServiceClient is the client API for ServiceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServiceServiceClient interface {
	Create(ctx context.Context, in *Service, opts ...grpc.CallOption) (*Service, error)
	Update(ctx context.Context, in *Service, opts ...grpc.CallOption) (*Service, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Service, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ServiceList, error)
}

type serviceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewServiceServiceClient(cc grpc.ClientConnInterface) ServiceServiceClient {
	return &serviceServiceClient{cc}
}

func (c *serviceServiceClient) Create(ctx context.Context, in *Service, opts ...grpc.CallOption) (*Service, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Service)
	err := c.cc.Invoke(ctx, ServiceService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceServiceClient) Update(ctx context.Context, in *Service, opts ...grpc.CallOption) (*Service, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Service)
	err := c.cc.Invoke(ctx, ServiceService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ServiceService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Service, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Service)
	err := c.cc.Invoke(ctx, ServiceService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ServiceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServiceList)
	err := c.cc.Invoke(ctx, ServiceService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServiceServiceServer is the server API for ServiceService service.
// All implementations must embed UnimplementedServiceServiceServer
// for forward compatibility
type ServiceServiceServer interface {
	Create(context.Context, *Service) (*Service, error)
	Update(context.Context, *Service) (*Service, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*Service, error)
	Find(context.Context, *GetListFilter) (*ServiceList, error)
	mustEmbedUnimplementedServiceServiceServer()
}

// UnimplementedServiceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedServiceServiceServer struct {
}

func (UnimplementedServiceServiceServer) Create(context.Context, *Service) (*Service, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedServiceServiceServer) Update(context.Context, *Service) (*Service, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedServiceServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedServiceServiceServer) Get(context.Context, *Id) (*Service, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedServiceServiceServer) Find(context.Context, *GetListFilter) (*ServiceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedServiceServiceServer) mustEmbedUnimplementedServiceServiceServer() {}

// UnsafeServiceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServiceServiceServer will
// result in compilation errors.
type UnsafeServiceServiceServer interface {
	mustEmbedUnimplementedServiceServiceServer()
}

func RegisterServiceServiceServer(s grpc.ServiceRegistrar, srv ServiceServiceServer) {
	s.RegisterService(&ServiceService_ServiceDesc, srv)
}

func _ServiceService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Service)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServiceServer).Create(ctx, req.(*Service))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Service)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServiceServer).Update(ctx, req.(*Service))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// ServiceService_ServiceDesc is the grpc.ServiceDesc for ServiceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ServiceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.ServiceService",
	HandlerType: (*ServiceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ServiceService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ServiceService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ServiceService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ServiceService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _ServiceService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	UnitDispatchStatusService_Create_FullMethodName      = "/company_service.UnitDispatchStatusService/Create"
	UnitDispatchStatusService_Update_FullMethodName      = "/company_service.UnitDispatchStatusService/Update"
	UnitDispatchStatusService_Delete_FullMethodName      = "/company_service.UnitDispatchStatusService/Delete"
	UnitDispatchStatusService_Get_FullMethodName         = "/company_service.UnitDispatchStatusService/Get"
	UnitDispatchStatusService_Find_FullMethodName        = "/company_service.UnitDispatchStatusService/Find"
	UnitDispatchStatusService_UpdateOrder_FullMethodName = "/company_service.UnitDispatchStatusService/UpdateOrder"
)

// UnitDispatchStatusServiceClient is the client API for UnitDispatchStatusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UnitDispatchStatusServiceClient interface {
	Create(ctx context.Context, in *UnitDispatchStatus, opts ...grpc.CallOption) (*UnitDispatchStatus, error)
	Update(ctx context.Context, in *UnitDispatchStatus, opts ...grpc.CallOption) (*UnitDispatchStatus, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*UnitDispatchStatus, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*UnitDispatchStatusList, error)
	UpdateOrder(ctx context.Context, in *UpdateOrderRequest, opts ...grpc.CallOption) (*Empty, error)
}

type unitDispatchStatusServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUnitDispatchStatusServiceClient(cc grpc.ClientConnInterface) UnitDispatchStatusServiceClient {
	return &unitDispatchStatusServiceClient{cc}
}

func (c *unitDispatchStatusServiceClient) Create(ctx context.Context, in *UnitDispatchStatus, opts ...grpc.CallOption) (*UnitDispatchStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnitDispatchStatus)
	err := c.cc.Invoke(ctx, UnitDispatchStatusService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitDispatchStatusServiceClient) Update(ctx context.Context, in *UnitDispatchStatus, opts ...grpc.CallOption) (*UnitDispatchStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnitDispatchStatus)
	err := c.cc.Invoke(ctx, UnitDispatchStatusService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitDispatchStatusServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UnitDispatchStatusService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitDispatchStatusServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*UnitDispatchStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnitDispatchStatus)
	err := c.cc.Invoke(ctx, UnitDispatchStatusService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitDispatchStatusServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*UnitDispatchStatusList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnitDispatchStatusList)
	err := c.cc.Invoke(ctx, UnitDispatchStatusService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitDispatchStatusServiceClient) UpdateOrder(ctx context.Context, in *UpdateOrderRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UnitDispatchStatusService_UpdateOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UnitDispatchStatusServiceServer is the server API for UnitDispatchStatusService service.
// All implementations must embed UnimplementedUnitDispatchStatusServiceServer
// for forward compatibility
type UnitDispatchStatusServiceServer interface {
	Create(context.Context, *UnitDispatchStatus) (*UnitDispatchStatus, error)
	Update(context.Context, *UnitDispatchStatus) (*UnitDispatchStatus, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*UnitDispatchStatus, error)
	Find(context.Context, *GetListFilter) (*UnitDispatchStatusList, error)
	UpdateOrder(context.Context, *UpdateOrderRequest) (*Empty, error)
	mustEmbedUnimplementedUnitDispatchStatusServiceServer()
}

// UnimplementedUnitDispatchStatusServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUnitDispatchStatusServiceServer struct {
}

func (UnimplementedUnitDispatchStatusServiceServer) Create(context.Context, *UnitDispatchStatus) (*UnitDispatchStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedUnitDispatchStatusServiceServer) Update(context.Context, *UnitDispatchStatus) (*UnitDispatchStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedUnitDispatchStatusServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedUnitDispatchStatusServiceServer) Get(context.Context, *Id) (*UnitDispatchStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedUnitDispatchStatusServiceServer) Find(context.Context, *GetListFilter) (*UnitDispatchStatusList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedUnitDispatchStatusServiceServer) UpdateOrder(context.Context, *UpdateOrderRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateOrder not implemented")
}
func (UnimplementedUnitDispatchStatusServiceServer) mustEmbedUnimplementedUnitDispatchStatusServiceServer() {
}

// UnsafeUnitDispatchStatusServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UnitDispatchStatusServiceServer will
// result in compilation errors.
type UnsafeUnitDispatchStatusServiceServer interface {
	mustEmbedUnimplementedUnitDispatchStatusServiceServer()
}

func RegisterUnitDispatchStatusServiceServer(s grpc.ServiceRegistrar, srv UnitDispatchStatusServiceServer) {
	s.RegisterService(&UnitDispatchStatusService_ServiceDesc, srv)
}

func _UnitDispatchStatusService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnitDispatchStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitDispatchStatusServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitDispatchStatusService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitDispatchStatusServiceServer).Create(ctx, req.(*UnitDispatchStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _UnitDispatchStatusService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnitDispatchStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitDispatchStatusServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitDispatchStatusService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitDispatchStatusServiceServer).Update(ctx, req.(*UnitDispatchStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _UnitDispatchStatusService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitDispatchStatusServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitDispatchStatusService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitDispatchStatusServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UnitDispatchStatusService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitDispatchStatusServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitDispatchStatusService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitDispatchStatusServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UnitDispatchStatusService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitDispatchStatusServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitDispatchStatusService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitDispatchStatusServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _UnitDispatchStatusService_UpdateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UnitDispatchStatusServiceServer).UpdateOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UnitDispatchStatusService_UpdateOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UnitDispatchStatusServiceServer).UpdateOrder(ctx, req.(*UpdateOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UnitDispatchStatusService_ServiceDesc is the grpc.ServiceDesc for UnitDispatchStatusService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UnitDispatchStatusService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.UnitDispatchStatusService",
	HandlerType: (*UnitDispatchStatusServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _UnitDispatchStatusService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _UnitDispatchStatusService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _UnitDispatchStatusService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _UnitDispatchStatusService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _UnitDispatchStatusService_Find_Handler,
		},
		{
			MethodName: "UpdateOrder",
			Handler:    _UnitDispatchStatusService_UpdateOrder_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	LoadManagementService_UpdateUnitDispatchStatus_FullMethodName = "/company_service.LoadManagementService/UpdateUnitDispatchStatus"
	LoadManagementService_Find_FullMethodName                     = "/company_service.LoadManagementService/Find"
	LoadManagementService_Get_FullMethodName                      = "/company_service.LoadManagementService/Get"
)

// LoadManagementServiceClient is the client API for LoadManagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoadManagementServiceClient interface {
	UpdateUnitDispatchStatus(ctx context.Context, in *UpdateUnitDispatchStatusRequest, opts ...grpc.CallOption) (*Empty, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*LoadManagmentList, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoadManagmentSingleItem, error)
}

type loadManagementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLoadManagementServiceClient(cc grpc.ClientConnInterface) LoadManagementServiceClient {
	return &loadManagementServiceClient{cc}
}

func (c *loadManagementServiceClient) UpdateUnitDispatchStatus(ctx context.Context, in *UpdateUnitDispatchStatusRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LoadManagementService_UpdateUnitDispatchStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadManagementServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*LoadManagmentList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadManagmentList)
	err := c.cc.Invoke(ctx, LoadManagementService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadManagementServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LoadManagmentSingleItem, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadManagmentSingleItem)
	err := c.cc.Invoke(ctx, LoadManagementService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoadManagementServiceServer is the server API for LoadManagementService service.
// All implementations must embed UnimplementedLoadManagementServiceServer
// for forward compatibility
type LoadManagementServiceServer interface {
	UpdateUnitDispatchStatus(context.Context, *UpdateUnitDispatchStatusRequest) (*Empty, error)
	Find(context.Context, *GetListFilter) (*LoadManagmentList, error)
	Get(context.Context, *Id) (*LoadManagmentSingleItem, error)
	mustEmbedUnimplementedLoadManagementServiceServer()
}

// UnimplementedLoadManagementServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLoadManagementServiceServer struct {
}

func (UnimplementedLoadManagementServiceServer) UpdateUnitDispatchStatus(context.Context, *UpdateUnitDispatchStatusRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUnitDispatchStatus not implemented")
}
func (UnimplementedLoadManagementServiceServer) Find(context.Context, *GetListFilter) (*LoadManagmentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedLoadManagementServiceServer) Get(context.Context, *Id) (*LoadManagmentSingleItem, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedLoadManagementServiceServer) mustEmbedUnimplementedLoadManagementServiceServer() {}

// UnsafeLoadManagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoadManagementServiceServer will
// result in compilation errors.
type UnsafeLoadManagementServiceServer interface {
	mustEmbedUnimplementedLoadManagementServiceServer()
}

func RegisterLoadManagementServiceServer(s grpc.ServiceRegistrar, srv LoadManagementServiceServer) {
	s.RegisterService(&LoadManagementService_ServiceDesc, srv)
}

func _LoadManagementService_UpdateUnitDispatchStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUnitDispatchStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadManagementServiceServer).UpdateUnitDispatchStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadManagementService_UpdateUnitDispatchStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadManagementServiceServer).UpdateUnitDispatchStatus(ctx, req.(*UpdateUnitDispatchStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadManagementService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadManagementServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadManagementService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadManagementServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadManagementService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadManagementServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoadManagementService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadManagementServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// LoadManagementService_ServiceDesc is the grpc.ServiceDesc for LoadManagementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoadManagementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.LoadManagementService",
	HandlerType: (*LoadManagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateUnitDispatchStatus",
			Handler:    _LoadManagementService_UpdateUnitDispatchStatus_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _LoadManagementService_Find_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _LoadManagementService_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}

const (
	CalendarNoteService_Create_FullMethodName = "/company_service.CalendarNoteService/Create"
	CalendarNoteService_Update_FullMethodName = "/company_service.CalendarNoteService/Update"
	CalendarNoteService_Delete_FullMethodName = "/company_service.CalendarNoteService/Delete"
	CalendarNoteService_Get_FullMethodName    = "/company_service.CalendarNoteService/Get"
	CalendarNoteService_Find_FullMethodName   = "/company_service.CalendarNoteService/Find"
)

// CalendarNoteServiceClient is the client API for CalendarNoteService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CalendarNoteServiceClient interface {
	Create(ctx context.Context, in *CalendarNote, opts ...grpc.CallOption) (*CalendarNote, error)
	Update(ctx context.Context, in *CalendarNote, opts ...grpc.CallOption) (*CalendarNote, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*CalendarNote, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*CalendarNoteList, error)
}

type calendarNoteServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCalendarNoteServiceClient(cc grpc.ClientConnInterface) CalendarNoteServiceClient {
	return &calendarNoteServiceClient{cc}
}

func (c *calendarNoteServiceClient) Create(ctx context.Context, in *CalendarNote, opts ...grpc.CallOption) (*CalendarNote, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CalendarNote)
	err := c.cc.Invoke(ctx, CalendarNoteService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarNoteServiceClient) Update(ctx context.Context, in *CalendarNote, opts ...grpc.CallOption) (*CalendarNote, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CalendarNote)
	err := c.cc.Invoke(ctx, CalendarNoteService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarNoteServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, CalendarNoteService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarNoteServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*CalendarNote, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CalendarNote)
	err := c.cc.Invoke(ctx, CalendarNoteService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarNoteServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*CalendarNoteList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CalendarNoteList)
	err := c.cc.Invoke(ctx, CalendarNoteService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CalendarNoteServiceServer is the server API for CalendarNoteService service.
// All implementations must embed UnimplementedCalendarNoteServiceServer
// for forward compatibility
type CalendarNoteServiceServer interface {
	Create(context.Context, *CalendarNote) (*CalendarNote, error)
	Update(context.Context, *CalendarNote) (*CalendarNote, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*CalendarNote, error)
	Find(context.Context, *GetListFilter) (*CalendarNoteList, error)
	mustEmbedUnimplementedCalendarNoteServiceServer()
}

// UnimplementedCalendarNoteServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCalendarNoteServiceServer struct {
}

func (UnimplementedCalendarNoteServiceServer) Create(context.Context, *CalendarNote) (*CalendarNote, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedCalendarNoteServiceServer) Update(context.Context, *CalendarNote) (*CalendarNote, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedCalendarNoteServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedCalendarNoteServiceServer) Get(context.Context, *Id) (*CalendarNote, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedCalendarNoteServiceServer) Find(context.Context, *GetListFilter) (*CalendarNoteList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedCalendarNoteServiceServer) mustEmbedUnimplementedCalendarNoteServiceServer() {}

// UnsafeCalendarNoteServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CalendarNoteServiceServer will
// result in compilation errors.
type UnsafeCalendarNoteServiceServer interface {
	mustEmbedUnimplementedCalendarNoteServiceServer()
}

func RegisterCalendarNoteServiceServer(s grpc.ServiceRegistrar, srv CalendarNoteServiceServer) {
	s.RegisterService(&CalendarNoteService_ServiceDesc, srv)
}

func _CalendarNoteService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalendarNote)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarNoteServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CalendarNoteService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarNoteServiceServer).Create(ctx, req.(*CalendarNote))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarNoteService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalendarNote)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarNoteServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CalendarNoteService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarNoteServiceServer).Update(ctx, req.(*CalendarNote))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarNoteService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarNoteServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CalendarNoteService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarNoteServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarNoteService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarNoteServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CalendarNoteService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarNoteServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarNoteService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarNoteServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CalendarNoteService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarNoteServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// CalendarNoteService_ServiceDesc is the grpc.ServiceDesc for CalendarNoteService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CalendarNoteService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "company_service.CalendarNoteService",
	HandlerType: (*CalendarNoteServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _CalendarNoteService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _CalendarNoteService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _CalendarNoteService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _CalendarNoteService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _CalendarNoteService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "company_service.proto",
}
