// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.12.4
// source: event_service.proto

package event_service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	HealthCheckService_HealthCheck_FullMethodName = "/event_service.HealthCheckService/HealthCheck"
)

// HealthCheckServiceClient is the client API for HealthCheckService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthCheckServiceClient interface {
	HealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type healthCheckServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthCheckServiceClient(cc grpc.ClientConnInterface) HealthCheckServiceClient {
	return &healthCheckServiceClient{cc}
}

func (c *healthCheckServiceClient) HealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, HealthCheckService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthCheckServiceServer is the server API for HealthCheckService service.
// All implementations must embed UnimplementedHealthCheckServiceServer
// for forward compatibility
type HealthCheckServiceServer interface {
	HealthCheck(context.Context, *Empty) (*HealthCheckResponse, error)
	mustEmbedUnimplementedHealthCheckServiceServer()
}

// UnimplementedHealthCheckServiceServer must be embedded to have forward compatible implementations.
type UnimplementedHealthCheckServiceServer struct {
}

func (UnimplementedHealthCheckServiceServer) HealthCheck(context.Context, *Empty) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedHealthCheckServiceServer) mustEmbedUnimplementedHealthCheckServiceServer() {}

// UnsafeHealthCheckServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthCheckServiceServer will
// result in compilation errors.
type UnsafeHealthCheckServiceServer interface {
	mustEmbedUnimplementedHealthCheckServiceServer()
}

func RegisterHealthCheckServiceServer(s grpc.ServiceRegistrar, srv HealthCheckServiceServer) {
	s.RegisterService(&HealthCheckService_ServiceDesc, srv)
}

func _HealthCheckService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthCheckServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthCheckService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthCheckServiceServer).HealthCheck(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthCheckService_ServiceDesc is the grpc.ServiceDesc for HealthCheckService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthCheckService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "event_service.HealthCheckService",
	HandlerType: (*HealthCheckServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HealthCheck",
			Handler:    _HealthCheckService_HealthCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "event_service.proto",
}

const (
	ViolationService_Find_FullMethodName = "/event_service.ViolationService/Find"
)

// ViolationServiceClient is the client API for ViolationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ViolationServiceClient interface {
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ListViolationLog, error)
}

type violationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewViolationServiceClient(cc grpc.ClientConnInterface) ViolationServiceClient {
	return &violationServiceClient{cc}
}

func (c *violationServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ListViolationLog, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListViolationLog)
	err := c.cc.Invoke(ctx, ViolationService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ViolationServiceServer is the server API for ViolationService service.
// All implementations must embed UnimplementedViolationServiceServer
// for forward compatibility
type ViolationServiceServer interface {
	Find(context.Context, *GetListFilter) (*ListViolationLog, error)
	mustEmbedUnimplementedViolationServiceServer()
}

// UnimplementedViolationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedViolationServiceServer struct {
}

func (UnimplementedViolationServiceServer) Find(context.Context, *GetListFilter) (*ListViolationLog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedViolationServiceServer) mustEmbedUnimplementedViolationServiceServer() {}

// UnsafeViolationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ViolationServiceServer will
// result in compilation errors.
type UnsafeViolationServiceServer interface {
	mustEmbedUnimplementedViolationServiceServer()
}

func RegisterViolationServiceServer(s grpc.ServiceRegistrar, srv ViolationServiceServer) {
	s.RegisterService(&ViolationService_ServiceDesc, srv)
}

func _ViolationService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViolationServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViolationService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViolationServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// ViolationService_ServiceDesc is the grpc.ServiceDesc for ViolationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ViolationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "event_service.ViolationService",
	HandlerType: (*ViolationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Find",
			Handler:    _ViolationService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "event_service.proto",
}

const (
	ChangeLogService_Create_FullMethodName     = "/event_service.ChangeLogService/Create"
	ChangeLogService_Find_FullMethodName       = "/event_service.ChangeLogService/Find"
	ChangeLogService_DeleteMany_FullMethodName = "/event_service.ChangeLogService/DeleteMany"
	ChangeLogService_Delete_FullMethodName     = "/event_service.ChangeLogService/Delete"
)

// ChangeLogServiceClient is the client API for ChangeLogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChangeLogServiceClient interface {
	Create(ctx context.Context, in *ChangeLog, opts ...grpc.CallOption) (*ChangeLog, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ChangeLogList, error)
	DeleteMany(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Empty, error)
	Delete(ctx context.Context, in *ChangeLogDeleteRequest, opts ...grpc.CallOption) (*Empty, error)
}

type changeLogServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChangeLogServiceClient(cc grpc.ClientConnInterface) ChangeLogServiceClient {
	return &changeLogServiceClient{cc}
}

func (c *changeLogServiceClient) Create(ctx context.Context, in *ChangeLog, opts ...grpc.CallOption) (*ChangeLog, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeLog)
	err := c.cc.Invoke(ctx, ChangeLogService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changeLogServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ChangeLogList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeLogList)
	err := c.cc.Invoke(ctx, ChangeLogService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changeLogServiceClient) DeleteMany(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ChangeLogService_DeleteMany_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changeLogServiceClient) Delete(ctx context.Context, in *ChangeLogDeleteRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ChangeLogService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChangeLogServiceServer is the server API for ChangeLogService service.
// All implementations must embed UnimplementedChangeLogServiceServer
// for forward compatibility
type ChangeLogServiceServer interface {
	Create(context.Context, *ChangeLog) (*ChangeLog, error)
	Find(context.Context, *GetListFilter) (*ChangeLogList, error)
	DeleteMany(context.Context, *Ids) (*Empty, error)
	Delete(context.Context, *ChangeLogDeleteRequest) (*Empty, error)
	mustEmbedUnimplementedChangeLogServiceServer()
}

// UnimplementedChangeLogServiceServer must be embedded to have forward compatible implementations.
type UnimplementedChangeLogServiceServer struct {
}

func (UnimplementedChangeLogServiceServer) Create(context.Context, *ChangeLog) (*ChangeLog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedChangeLogServiceServer) Find(context.Context, *GetListFilter) (*ChangeLogList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedChangeLogServiceServer) DeleteMany(context.Context, *Ids) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMany not implemented")
}
func (UnimplementedChangeLogServiceServer) Delete(context.Context, *ChangeLogDeleteRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedChangeLogServiceServer) mustEmbedUnimplementedChangeLogServiceServer() {}

// UnsafeChangeLogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChangeLogServiceServer will
// result in compilation errors.
type UnsafeChangeLogServiceServer interface {
	mustEmbedUnimplementedChangeLogServiceServer()
}

func RegisterChangeLogServiceServer(s grpc.ServiceRegistrar, srv ChangeLogServiceServer) {
	s.RegisterService(&ChangeLogService_ServiceDesc, srv)
}

func _ChangeLogService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChangeLogServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChangeLogService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChangeLogServiceServer).Create(ctx, req.(*ChangeLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChangeLogService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChangeLogServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChangeLogService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChangeLogServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChangeLogService_DeleteMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChangeLogServiceServer).DeleteMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChangeLogService_DeleteMany_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChangeLogServiceServer).DeleteMany(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChangeLogService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeLogDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChangeLogServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChangeLogService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChangeLogServiceServer).Delete(ctx, req.(*ChangeLogDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChangeLogService_ServiceDesc is the grpc.ServiceDesc for ChangeLogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChangeLogService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "event_service.ChangeLogService",
	HandlerType: (*ChangeLogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ChangeLogService_Create_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _ChangeLogService_Find_Handler,
		},
		{
			MethodName: "DeleteMany",
			Handler:    _ChangeLogService_DeleteMany_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ChangeLogService_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "event_service.proto",
}

const (
	TrackingService_Create_FullMethodName                      = "/event_service.TrackingService/Create"
	TrackingService_Find_FullMethodName                        = "/event_service.TrackingService/Find"
	TrackingService_FindLight_FullMethodName                   = "/event_service.TrackingService/FindLight"
	TrackingService_GetLastState_FullMethodName                = "/event_service.TrackingService/GetLastState"
	TrackingService_MultipleGetLastState_FullMethodName        = "/event_service.TrackingService/MultipleGetLastState"
	TrackingService_ManualUpdateCurrentLocation_FullMethodName = "/event_service.TrackingService/ManualUpdateCurrentLocation"
	TrackingService_GetDriverStatusCount_FullMethodName        = "/event_service.TrackingService/GetDriverStatusCount"
)

// TrackingServiceClient is the client API for TrackingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TrackingServiceClient interface {
	Create(ctx context.Context, in *TrackingCreateRequest, opts ...grpc.CallOption) (*Empty, error)
	Find(ctx context.Context, in *TrackingListRequest, opts ...grpc.CallOption) (*TrackingListResponse, error)
	FindLight(ctx context.Context, in *TrackingListRequest, opts ...grpc.CallOption) (*TrackingListLightResponse, error)
	GetLastState(ctx context.Context, in *LastStateRequest, opts ...grpc.CallOption) (*LastStateResponse, error)
	MultipleGetLastState(ctx context.Context, in *MultipleLastStateRequest, opts ...grpc.CallOption) (*MultipelLastStateResponse, error)
	ManualUpdateCurrentLocation(ctx context.Context, in *ManualLastLocation, opts ...grpc.CallOption) (*Empty, error)
	GetDriverStatusCount(ctx context.Context, in *MultipleLastStateRequest, opts ...grpc.CallOption) (*StatusCount, error)
}

type trackingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTrackingServiceClient(cc grpc.ClientConnInterface) TrackingServiceClient {
	return &trackingServiceClient{cc}
}

func (c *trackingServiceClient) Create(ctx context.Context, in *TrackingCreateRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TrackingService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trackingServiceClient) Find(ctx context.Context, in *TrackingListRequest, opts ...grpc.CallOption) (*TrackingListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TrackingListResponse)
	err := c.cc.Invoke(ctx, TrackingService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trackingServiceClient) FindLight(ctx context.Context, in *TrackingListRequest, opts ...grpc.CallOption) (*TrackingListLightResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TrackingListLightResponse)
	err := c.cc.Invoke(ctx, TrackingService_FindLight_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trackingServiceClient) GetLastState(ctx context.Context, in *LastStateRequest, opts ...grpc.CallOption) (*LastStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LastStateResponse)
	err := c.cc.Invoke(ctx, TrackingService_GetLastState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trackingServiceClient) MultipleGetLastState(ctx context.Context, in *MultipleLastStateRequest, opts ...grpc.CallOption) (*MultipelLastStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MultipelLastStateResponse)
	err := c.cc.Invoke(ctx, TrackingService_MultipleGetLastState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trackingServiceClient) ManualUpdateCurrentLocation(ctx context.Context, in *ManualLastLocation, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TrackingService_ManualUpdateCurrentLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trackingServiceClient) GetDriverStatusCount(ctx context.Context, in *MultipleLastStateRequest, opts ...grpc.CallOption) (*StatusCount, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusCount)
	err := c.cc.Invoke(ctx, TrackingService_GetDriverStatusCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TrackingServiceServer is the server API for TrackingService service.
// All implementations must embed UnimplementedTrackingServiceServer
// for forward compatibility
type TrackingServiceServer interface {
	Create(context.Context, *TrackingCreateRequest) (*Empty, error)
	Find(context.Context, *TrackingListRequest) (*TrackingListResponse, error)
	FindLight(context.Context, *TrackingListRequest) (*TrackingListLightResponse, error)
	GetLastState(context.Context, *LastStateRequest) (*LastStateResponse, error)
	MultipleGetLastState(context.Context, *MultipleLastStateRequest) (*MultipelLastStateResponse, error)
	ManualUpdateCurrentLocation(context.Context, *ManualLastLocation) (*Empty, error)
	GetDriverStatusCount(context.Context, *MultipleLastStateRequest) (*StatusCount, error)
	mustEmbedUnimplementedTrackingServiceServer()
}

// UnimplementedTrackingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTrackingServiceServer struct {
}

func (UnimplementedTrackingServiceServer) Create(context.Context, *TrackingCreateRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedTrackingServiceServer) Find(context.Context, *TrackingListRequest) (*TrackingListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedTrackingServiceServer) FindLight(context.Context, *TrackingListRequest) (*TrackingListLightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindLight not implemented")
}
func (UnimplementedTrackingServiceServer) GetLastState(context.Context, *LastStateRequest) (*LastStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastState not implemented")
}
func (UnimplementedTrackingServiceServer) MultipleGetLastState(context.Context, *MultipleLastStateRequest) (*MultipelLastStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultipleGetLastState not implemented")
}
func (UnimplementedTrackingServiceServer) ManualUpdateCurrentLocation(context.Context, *ManualLastLocation) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ManualUpdateCurrentLocation not implemented")
}
func (UnimplementedTrackingServiceServer) GetDriverStatusCount(context.Context, *MultipleLastStateRequest) (*StatusCount, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDriverStatusCount not implemented")
}
func (UnimplementedTrackingServiceServer) mustEmbedUnimplementedTrackingServiceServer() {}

// UnsafeTrackingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TrackingServiceServer will
// result in compilation errors.
type UnsafeTrackingServiceServer interface {
	mustEmbedUnimplementedTrackingServiceServer()
}

func RegisterTrackingServiceServer(s grpc.ServiceRegistrar, srv TrackingServiceServer) {
	s.RegisterService(&TrackingService_ServiceDesc, srv)
}

func _TrackingService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackingCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrackingServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrackingService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrackingServiceServer).Create(ctx, req.(*TrackingCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrackingService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackingListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrackingServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrackingService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrackingServiceServer).Find(ctx, req.(*TrackingListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrackingService_FindLight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackingListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrackingServiceServer).FindLight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrackingService_FindLight_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrackingServiceServer).FindLight(ctx, req.(*TrackingListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrackingService_GetLastState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LastStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrackingServiceServer).GetLastState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrackingService_GetLastState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrackingServiceServer).GetLastState(ctx, req.(*LastStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrackingService_MultipleGetLastState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultipleLastStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrackingServiceServer).MultipleGetLastState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrackingService_MultipleGetLastState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrackingServiceServer).MultipleGetLastState(ctx, req.(*MultipleLastStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrackingService_ManualUpdateCurrentLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ManualLastLocation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrackingServiceServer).ManualUpdateCurrentLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrackingService_ManualUpdateCurrentLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrackingServiceServer).ManualUpdateCurrentLocation(ctx, req.(*ManualLastLocation))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrackingService_GetDriverStatusCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultipleLastStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrackingServiceServer).GetDriverStatusCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrackingService_GetDriverStatusCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrackingServiceServer).GetDriverStatusCount(ctx, req.(*MultipleLastStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TrackingService_ServiceDesc is the grpc.ServiceDesc for TrackingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TrackingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "event_service.TrackingService",
	HandlerType: (*TrackingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _TrackingService_Create_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _TrackingService_Find_Handler,
		},
		{
			MethodName: "FindLight",
			Handler:    _TrackingService_FindLight_Handler,
		},
		{
			MethodName: "GetLastState",
			Handler:    _TrackingService_GetLastState_Handler,
		},
		{
			MethodName: "MultipleGetLastState",
			Handler:    _TrackingService_MultipleGetLastState_Handler,
		},
		{
			MethodName: "ManualUpdateCurrentLocation",
			Handler:    _TrackingService_ManualUpdateCurrentLocation_Handler,
		},
		{
			MethodName: "GetDriverStatusCount",
			Handler:    _TrackingService_GetDriverStatusCount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "event_service.proto",
}

const (
	LogService_Create_FullMethodName                = "/event_service.LogService/Create"
	LogService_Find_FullMethodName                  = "/event_service.LogService/Find"
	LogService_MultipleGet_FullMethodName           = "/event_service.LogService/MultipleGet"
	LogService_GetSingle_FullMethodName             = "/event_service.LogService/GetSingle"
	LogService_DirectEdit_FullMethodName            = "/event_service.LogService/DirectEdit"
	LogService_GetSingleDriverTimer_FullMethodName  = "/event_service.LogService/GetSingleDriverTimer"
	LogService_MultipleGetDriverTime_FullMethodName = "/event_service.LogService/MultipleGetDriverTime"
	LogService_GetListLogsByDriver_FullMethodName   = "/event_service.LogService/GetListLogsByDriver"
	LogService_InsertDutyLog_FullMethodName         = "/event_service.LogService/InsertDutyLog"
	LogService_GetCertifyLog_FullMethodName         = "/event_service.LogService/GetCertifyLog"
	LogService_MultipleInsertLog_FullMethodName     = "/event_service.LogService/MultipleInsertLog"
	LogService_VerifyInsertInfoLog_FullMethodName   = "/event_service.LogService/VerifyInsertInfoLog"
	LogService_Update_FullMethodName                = "/event_service.LogService/Update"
	LogService_Delete_FullMethodName                = "/event_service.LogService/Delete"
	LogService_MultipleGetTimer_FullMethodName      = "/event_service.LogService/MultipleGetTimer"
	LogService_Swap_FullMethodName                  = "/event_service.LogService/Swap"
	LogService_GetLastDutyStatus_FullMethodName     = "/event_service.LogService/GetLastDutyStatus"
	LogService_Transfer_FullMethodName              = "/event_service.LogService/Transfer"
	LogService_Normalize_FullMethodName             = "/event_service.LogService/Normalize"
	LogService_BulkEdit_FullMethodName              = "/event_service.LogService/BulkEdit"
	LogService_Reassign_FullMethodName              = "/event_service.LogService/Reassign"
)

// LogServiceClient is the client API for LogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogServiceClient interface {
	Create(ctx context.Context, in *Log, opts ...grpc.CallOption) (*CreateResponse, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*LogListResponse, error)
	MultipleGet(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*LogListResponse, error)
	GetSingle(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LogSingleResponse, error)
	DirectEdit(ctx context.Context, in *DirectEditRequest, opts ...grpc.CallOption) (*Empty, error)
	GetSingleDriverTimer(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Timer, error)
	MultipleGetDriverTime(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*ListTimer, error)
	GetListLogsByDriver(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ListDriverLogsNdays, error)
	InsertDutyLog(ctx context.Context, in *CorrectionDutyLog, opts ...grpc.CallOption) (*Empty, error)
	GetCertifyLog(ctx context.Context, in *CertifyLog, opts ...grpc.CallOption) (*ListCertifyLog, error)
	MultipleInsertLog(ctx context.Context, in *CertifyLogRequest, opts ...grpc.CallOption) (*Empty, error)
	VerifyInsertInfoLog(ctx context.Context, in *VerifyInsertLog, opts ...grpc.CallOption) (*Empty, error)
	Update(ctx context.Context, in *UpdateLog, opts ...grpc.CallOption) (*Empty, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	MultipleGetTimer(ctx context.Context, in *GetTimerList, opts ...grpc.CallOption) (*TimerList, error)
	Swap(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*Empty, error)
	GetLastDutyStatus(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LogSingleResponse, error)
	Transfer(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*Empty, error)
	Normalize(ctx context.Context, in *NormalizeRequest, opts ...grpc.CallOption) (*Empty, error)
	BulkEdit(ctx context.Context, in *BulkEditRequest, opts ...grpc.CallOption) (*Empty, error)
	Reassign(ctx context.Context, in *ReassignRequest, opts ...grpc.CallOption) (*Empty, error)
}

type logServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLogServiceClient(cc grpc.ClientConnInterface) LogServiceClient {
	return &logServiceClient{cc}
}

func (c *logServiceClient) Create(ctx context.Context, in *Log, opts ...grpc.CallOption) (*CreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateResponse)
	err := c.cc.Invoke(ctx, LogService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*LogListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogListResponse)
	err := c.cc.Invoke(ctx, LogService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) MultipleGet(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*LogListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogListResponse)
	err := c.cc.Invoke(ctx, LogService_MultipleGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) GetSingle(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LogSingleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogSingleResponse)
	err := c.cc.Invoke(ctx, LogService_GetSingle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) DirectEdit(ctx context.Context, in *DirectEditRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LogService_DirectEdit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) GetSingleDriverTimer(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Timer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Timer)
	err := c.cc.Invoke(ctx, LogService_GetSingleDriverTimer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) MultipleGetDriverTime(ctx context.Context, in *Ids, opts ...grpc.CallOption) (*ListTimer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTimer)
	err := c.cc.Invoke(ctx, LogService_MultipleGetDriverTime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) GetListLogsByDriver(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ListDriverLogsNdays, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDriverLogsNdays)
	err := c.cc.Invoke(ctx, LogService_GetListLogsByDriver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) InsertDutyLog(ctx context.Context, in *CorrectionDutyLog, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LogService_InsertDutyLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) GetCertifyLog(ctx context.Context, in *CertifyLog, opts ...grpc.CallOption) (*ListCertifyLog, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCertifyLog)
	err := c.cc.Invoke(ctx, LogService_GetCertifyLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) MultipleInsertLog(ctx context.Context, in *CertifyLogRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LogService_MultipleInsertLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) VerifyInsertInfoLog(ctx context.Context, in *VerifyInsertLog, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LogService_VerifyInsertInfoLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) Update(ctx context.Context, in *UpdateLog, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LogService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LogService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) MultipleGetTimer(ctx context.Context, in *GetTimerList, opts ...grpc.CallOption) (*TimerList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TimerList)
	err := c.cc.Invoke(ctx, LogService_MultipleGetTimer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) Swap(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LogService_Swap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) GetLastDutyStatus(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LogSingleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogSingleResponse)
	err := c.cc.Invoke(ctx, LogService_GetLastDutyStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) Transfer(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LogService_Transfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) Normalize(ctx context.Context, in *NormalizeRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LogService_Normalize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) BulkEdit(ctx context.Context, in *BulkEditRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LogService_BulkEdit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logServiceClient) Reassign(ctx context.Context, in *ReassignRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LogService_Reassign_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LogServiceServer is the server API for LogService service.
// All implementations must embed UnimplementedLogServiceServer
// for forward compatibility
type LogServiceServer interface {
	Create(context.Context, *Log) (*CreateResponse, error)
	Find(context.Context, *GetListFilter) (*LogListResponse, error)
	MultipleGet(context.Context, *Ids) (*LogListResponse, error)
	GetSingle(context.Context, *Id) (*LogSingleResponse, error)
	DirectEdit(context.Context, *DirectEditRequest) (*Empty, error)
	GetSingleDriverTimer(context.Context, *Id) (*Timer, error)
	MultipleGetDriverTime(context.Context, *Ids) (*ListTimer, error)
	GetListLogsByDriver(context.Context, *GetListFilter) (*ListDriverLogsNdays, error)
	InsertDutyLog(context.Context, *CorrectionDutyLog) (*Empty, error)
	GetCertifyLog(context.Context, *CertifyLog) (*ListCertifyLog, error)
	MultipleInsertLog(context.Context, *CertifyLogRequest) (*Empty, error)
	VerifyInsertInfoLog(context.Context, *VerifyInsertLog) (*Empty, error)
	Update(context.Context, *UpdateLog) (*Empty, error)
	Delete(context.Context, *Id) (*Empty, error)
	MultipleGetTimer(context.Context, *GetTimerList) (*TimerList, error)
	Swap(context.Context, *TransferRequest) (*Empty, error)
	GetLastDutyStatus(context.Context, *Id) (*LogSingleResponse, error)
	Transfer(context.Context, *TransferRequest) (*Empty, error)
	Normalize(context.Context, *NormalizeRequest) (*Empty, error)
	BulkEdit(context.Context, *BulkEditRequest) (*Empty, error)
	Reassign(context.Context, *ReassignRequest) (*Empty, error)
	mustEmbedUnimplementedLogServiceServer()
}

// UnimplementedLogServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLogServiceServer struct {
}

func (UnimplementedLogServiceServer) Create(context.Context, *Log) (*CreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedLogServiceServer) Find(context.Context, *GetListFilter) (*LogListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedLogServiceServer) MultipleGet(context.Context, *Ids) (*LogListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultipleGet not implemented")
}
func (UnimplementedLogServiceServer) GetSingle(context.Context, *Id) (*LogSingleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSingle not implemented")
}
func (UnimplementedLogServiceServer) DirectEdit(context.Context, *DirectEditRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DirectEdit not implemented")
}
func (UnimplementedLogServiceServer) GetSingleDriverTimer(context.Context, *Id) (*Timer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSingleDriverTimer not implemented")
}
func (UnimplementedLogServiceServer) MultipleGetDriverTime(context.Context, *Ids) (*ListTimer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultipleGetDriverTime not implemented")
}
func (UnimplementedLogServiceServer) GetListLogsByDriver(context.Context, *GetListFilter) (*ListDriverLogsNdays, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetListLogsByDriver not implemented")
}
func (UnimplementedLogServiceServer) InsertDutyLog(context.Context, *CorrectionDutyLog) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertDutyLog not implemented")
}
func (UnimplementedLogServiceServer) GetCertifyLog(context.Context, *CertifyLog) (*ListCertifyLog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCertifyLog not implemented")
}
func (UnimplementedLogServiceServer) MultipleInsertLog(context.Context, *CertifyLogRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultipleInsertLog not implemented")
}
func (UnimplementedLogServiceServer) VerifyInsertInfoLog(context.Context, *VerifyInsertLog) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyInsertInfoLog not implemented")
}
func (UnimplementedLogServiceServer) Update(context.Context, *UpdateLog) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedLogServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedLogServiceServer) MultipleGetTimer(context.Context, *GetTimerList) (*TimerList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultipleGetTimer not implemented")
}
func (UnimplementedLogServiceServer) Swap(context.Context, *TransferRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Swap not implemented")
}
func (UnimplementedLogServiceServer) GetLastDutyStatus(context.Context, *Id) (*LogSingleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastDutyStatus not implemented")
}
func (UnimplementedLogServiceServer) Transfer(context.Context, *TransferRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Transfer not implemented")
}
func (UnimplementedLogServiceServer) Normalize(context.Context, *NormalizeRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Normalize not implemented")
}
func (UnimplementedLogServiceServer) BulkEdit(context.Context, *BulkEditRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkEdit not implemented")
}
func (UnimplementedLogServiceServer) Reassign(context.Context, *ReassignRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reassign not implemented")
}
func (UnimplementedLogServiceServer) mustEmbedUnimplementedLogServiceServer() {}

// UnsafeLogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogServiceServer will
// result in compilation errors.
type UnsafeLogServiceServer interface {
	mustEmbedUnimplementedLogServiceServer()
}

func RegisterLogServiceServer(s grpc.ServiceRegistrar, srv LogServiceServer) {
	s.RegisterService(&LogService_ServiceDesc, srv)
}

func _LogService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Log)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).Create(ctx, req.(*Log))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_MultipleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).MultipleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_MultipleGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).MultipleGet(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_GetSingle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).GetSingle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_GetSingle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).GetSingle(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_DirectEdit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DirectEditRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).DirectEdit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_DirectEdit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).DirectEdit(ctx, req.(*DirectEditRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_GetSingleDriverTimer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).GetSingleDriverTimer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_GetSingleDriverTimer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).GetSingleDriverTimer(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_MultipleGetDriverTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).MultipleGetDriverTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_MultipleGetDriverTime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).MultipleGetDriverTime(ctx, req.(*Ids))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_GetListLogsByDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).GetListLogsByDriver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_GetListLogsByDriver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).GetListLogsByDriver(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_InsertDutyLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CorrectionDutyLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).InsertDutyLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_InsertDutyLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).InsertDutyLog(ctx, req.(*CorrectionDutyLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_GetCertifyLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CertifyLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).GetCertifyLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_GetCertifyLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).GetCertifyLog(ctx, req.(*CertifyLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_MultipleInsertLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CertifyLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).MultipleInsertLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_MultipleInsertLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).MultipleInsertLog(ctx, req.(*CertifyLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_VerifyInsertInfoLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyInsertLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).VerifyInsertInfoLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_VerifyInsertInfoLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).VerifyInsertInfoLog(ctx, req.(*VerifyInsertLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).Update(ctx, req.(*UpdateLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_MultipleGetTimer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTimerList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).MultipleGetTimer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_MultipleGetTimer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).MultipleGetTimer(ctx, req.(*GetTimerList))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_Swap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).Swap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_Swap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).Swap(ctx, req.(*TransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_GetLastDutyStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).GetLastDutyStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_GetLastDutyStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).GetLastDutyStatus(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_Transfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).Transfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_Transfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).Transfer(ctx, req.(*TransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_Normalize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NormalizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).Normalize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_Normalize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).Normalize(ctx, req.(*NormalizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_BulkEdit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkEditRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).BulkEdit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_BulkEdit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).BulkEdit(ctx, req.(*BulkEditRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogService_Reassign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReassignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServiceServer).Reassign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LogService_Reassign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServiceServer).Reassign(ctx, req.(*ReassignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LogService_ServiceDesc is the grpc.ServiceDesc for LogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LogService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "event_service.LogService",
	HandlerType: (*LogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _LogService_Create_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _LogService_Find_Handler,
		},
		{
			MethodName: "MultipleGet",
			Handler:    _LogService_MultipleGet_Handler,
		},
		{
			MethodName: "GetSingle",
			Handler:    _LogService_GetSingle_Handler,
		},
		{
			MethodName: "DirectEdit",
			Handler:    _LogService_DirectEdit_Handler,
		},
		{
			MethodName: "GetSingleDriverTimer",
			Handler:    _LogService_GetSingleDriverTimer_Handler,
		},
		{
			MethodName: "MultipleGetDriverTime",
			Handler:    _LogService_MultipleGetDriverTime_Handler,
		},
		{
			MethodName: "GetListLogsByDriver",
			Handler:    _LogService_GetListLogsByDriver_Handler,
		},
		{
			MethodName: "InsertDutyLog",
			Handler:    _LogService_InsertDutyLog_Handler,
		},
		{
			MethodName: "GetCertifyLog",
			Handler:    _LogService_GetCertifyLog_Handler,
		},
		{
			MethodName: "MultipleInsertLog",
			Handler:    _LogService_MultipleInsertLog_Handler,
		},
		{
			MethodName: "VerifyInsertInfoLog",
			Handler:    _LogService_VerifyInsertInfoLog_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _LogService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _LogService_Delete_Handler,
		},
		{
			MethodName: "MultipleGetTimer",
			Handler:    _LogService_MultipleGetTimer_Handler,
		},
		{
			MethodName: "Swap",
			Handler:    _LogService_Swap_Handler,
		},
		{
			MethodName: "GetLastDutyStatus",
			Handler:    _LogService_GetLastDutyStatus_Handler,
		},
		{
			MethodName: "Transfer",
			Handler:    _LogService_Transfer_Handler,
		},
		{
			MethodName: "Normalize",
			Handler:    _LogService_Normalize_Handler,
		},
		{
			MethodName: "BulkEdit",
			Handler:    _LogService_BulkEdit_Handler,
		},
		{
			MethodName: "Reassign",
			Handler:    _LogService_Reassign_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "event_service.proto",
}

const (
	ChangeLogHistory_Create_FullMethodName = "/event_service.ChangeLogHistory/Create"
	ChangeLogHistory_Find_FullMethodName   = "/event_service.ChangeLogHistory/Find"
	ChangeLogHistory_Get_FullMethodName    = "/event_service.ChangeLogHistory/Get"
)

// ChangeLogHistoryClient is the client API for ChangeLogHistory service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChangeLogHistoryClient interface {
	Create(ctx context.Context, in *LogCHangeHistory, opts ...grpc.CallOption) (*Id, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ListLogCHangeHistory, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LogCHangeHistory, error)
}

type changeLogHistoryClient struct {
	cc grpc.ClientConnInterface
}

func NewChangeLogHistoryClient(cc grpc.ClientConnInterface) ChangeLogHistoryClient {
	return &changeLogHistoryClient{cc}
}

func (c *changeLogHistoryClient) Create(ctx context.Context, in *LogCHangeHistory, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, ChangeLogHistory_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changeLogHistoryClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ListLogCHangeHistory, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLogCHangeHistory)
	err := c.cc.Invoke(ctx, ChangeLogHistory_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changeLogHistoryClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*LogCHangeHistory, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogCHangeHistory)
	err := c.cc.Invoke(ctx, ChangeLogHistory_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChangeLogHistoryServer is the server API for ChangeLogHistory service.
// All implementations must embed UnimplementedChangeLogHistoryServer
// for forward compatibility
type ChangeLogHistoryServer interface {
	Create(context.Context, *LogCHangeHistory) (*Id, error)
	Find(context.Context, *GetListFilter) (*ListLogCHangeHistory, error)
	Get(context.Context, *Id) (*LogCHangeHistory, error)
	mustEmbedUnimplementedChangeLogHistoryServer()
}

// UnimplementedChangeLogHistoryServer must be embedded to have forward compatible implementations.
type UnimplementedChangeLogHistoryServer struct {
}

func (UnimplementedChangeLogHistoryServer) Create(context.Context, *LogCHangeHistory) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedChangeLogHistoryServer) Find(context.Context, *GetListFilter) (*ListLogCHangeHistory, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedChangeLogHistoryServer) Get(context.Context, *Id) (*LogCHangeHistory, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedChangeLogHistoryServer) mustEmbedUnimplementedChangeLogHistoryServer() {}

// UnsafeChangeLogHistoryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChangeLogHistoryServer will
// result in compilation errors.
type UnsafeChangeLogHistoryServer interface {
	mustEmbedUnimplementedChangeLogHistoryServer()
}

func RegisterChangeLogHistoryServer(s grpc.ServiceRegistrar, srv ChangeLogHistoryServer) {
	s.RegisterService(&ChangeLogHistory_ServiceDesc, srv)
}

func _ChangeLogHistory_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogCHangeHistory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChangeLogHistoryServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChangeLogHistory_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChangeLogHistoryServer).Create(ctx, req.(*LogCHangeHistory))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChangeLogHistory_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChangeLogHistoryServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChangeLogHistory_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChangeLogHistoryServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChangeLogHistory_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChangeLogHistoryServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChangeLogHistory_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChangeLogHistoryServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// ChangeLogHistory_ServiceDesc is the grpc.ServiceDesc for ChangeLogHistory service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChangeLogHistory_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "event_service.ChangeLogHistory",
	HandlerType: (*ChangeLogHistoryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ChangeLogHistory_Create_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _ChangeLogHistory_Find_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ChangeLogHistory_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "event_service.proto",
}

const (
	ReportService_GetByUnit_FullMethodName   = "/event_service.ReportService/GetByUnit"
	ReportService_GetAllState_FullMethodName = "/event_service.ReportService/GetAllState"
	ReportService_GetActivity_FullMethodName = "/event_service.ReportService/GetActivity"
)

// ReportServiceClient is the client API for ReportService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReportServiceClient interface {
	GetByUnit(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*IFTAreportList, error)
	GetAllState(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*IFTAReportByStateList, error)
	GetActivity(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ActivityReportList, error)
}

type reportServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReportServiceClient(cc grpc.ClientConnInterface) ReportServiceClient {
	return &reportServiceClient{cc}
}

func (c *reportServiceClient) GetByUnit(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*IFTAreportList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IFTAreportList)
	err := c.cc.Invoke(ctx, ReportService_GetByUnit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) GetAllState(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*IFTAReportByStateList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IFTAReportByStateList)
	err := c.cc.Invoke(ctx, ReportService_GetAllState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) GetActivity(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ActivityReportList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActivityReportList)
	err := c.cc.Invoke(ctx, ReportService_GetActivity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReportServiceServer is the server API for ReportService service.
// All implementations must embed UnimplementedReportServiceServer
// for forward compatibility
type ReportServiceServer interface {
	GetByUnit(context.Context, *GetListFilter) (*IFTAreportList, error)
	GetAllState(context.Context, *GetListFilter) (*IFTAReportByStateList, error)
	GetActivity(context.Context, *GetListFilter) (*ActivityReportList, error)
	mustEmbedUnimplementedReportServiceServer()
}

// UnimplementedReportServiceServer must be embedded to have forward compatible implementations.
type UnimplementedReportServiceServer struct {
}

func (UnimplementedReportServiceServer) GetByUnit(context.Context, *GetListFilter) (*IFTAreportList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByUnit not implemented")
}
func (UnimplementedReportServiceServer) GetAllState(context.Context, *GetListFilter) (*IFTAReportByStateList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllState not implemented")
}
func (UnimplementedReportServiceServer) GetActivity(context.Context, *GetListFilter) (*ActivityReportList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActivity not implemented")
}
func (UnimplementedReportServiceServer) mustEmbedUnimplementedReportServiceServer() {}

// UnsafeReportServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReportServiceServer will
// result in compilation errors.
type UnsafeReportServiceServer interface {
	mustEmbedUnimplementedReportServiceServer()
}

func RegisterReportServiceServer(s grpc.ServiceRegistrar, srv ReportServiceServer) {
	s.RegisterService(&ReportService_ServiceDesc, srv)
}

func _ReportService_GetByUnit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).GetByUnit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReportService_GetByUnit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).GetByUnit(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_GetAllState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).GetAllState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReportService_GetAllState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).GetAllState(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_GetActivity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).GetActivity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReportService_GetActivity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).GetActivity(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// ReportService_ServiceDesc is the grpc.ServiceDesc for ReportService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReportService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "event_service.ReportService",
	HandlerType: (*ReportServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetByUnit",
			Handler:    _ReportService_GetByUnit_Handler,
		},
		{
			MethodName: "GetAllState",
			Handler:    _ReportService_GetAllState_Handler,
		},
		{
			MethodName: "GetActivity",
			Handler:    _ReportService_GetActivity_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "event_service.proto",
}

const (
	DvirReportService_Create_FullMethodName = "/event_service.DvirReportService/Create"
	DvirReportService_Get_FullMethodName    = "/event_service.DvirReportService/Get"
	DvirReportService_Find_FullMethodName   = "/event_service.DvirReportService/Find"
	DvirReportService_Update_FullMethodName = "/event_service.DvirReportService/Update"
	DvirReportService_Delete_FullMethodName = "/event_service.DvirReportService/Delete"
)

// DvirReportServiceClient is the client API for DvirReportService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DvirReportServiceClient interface {
	Create(ctx context.Context, in *DvirReport, opts ...grpc.CallOption) (*DvirReport, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*DvirReport, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*DvirReportList, error)
	Update(ctx context.Context, in *DvirReport, opts ...grpc.CallOption) (*DvirReport, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
}

type dvirReportServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDvirReportServiceClient(cc grpc.ClientConnInterface) DvirReportServiceClient {
	return &dvirReportServiceClient{cc}
}

func (c *dvirReportServiceClient) Create(ctx context.Context, in *DvirReport, opts ...grpc.CallOption) (*DvirReport, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DvirReport)
	err := c.cc.Invoke(ctx, DvirReportService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dvirReportServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*DvirReport, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DvirReport)
	err := c.cc.Invoke(ctx, DvirReportService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dvirReportServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*DvirReportList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DvirReportList)
	err := c.cc.Invoke(ctx, DvirReportService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dvirReportServiceClient) Update(ctx context.Context, in *DvirReport, opts ...grpc.CallOption) (*DvirReport, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DvirReport)
	err := c.cc.Invoke(ctx, DvirReportService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dvirReportServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, DvirReportService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DvirReportServiceServer is the server API for DvirReportService service.
// All implementations must embed UnimplementedDvirReportServiceServer
// for forward compatibility
type DvirReportServiceServer interface {
	Create(context.Context, *DvirReport) (*DvirReport, error)
	Get(context.Context, *Id) (*DvirReport, error)
	Find(context.Context, *GetListFilter) (*DvirReportList, error)
	Update(context.Context, *DvirReport) (*DvirReport, error)
	Delete(context.Context, *Id) (*Empty, error)
	mustEmbedUnimplementedDvirReportServiceServer()
}

// UnimplementedDvirReportServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDvirReportServiceServer struct {
}

func (UnimplementedDvirReportServiceServer) Create(context.Context, *DvirReport) (*DvirReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedDvirReportServiceServer) Get(context.Context, *Id) (*DvirReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDvirReportServiceServer) Find(context.Context, *GetListFilter) (*DvirReportList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedDvirReportServiceServer) Update(context.Context, *DvirReport) (*DvirReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedDvirReportServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedDvirReportServiceServer) mustEmbedUnimplementedDvirReportServiceServer() {}

// UnsafeDvirReportServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DvirReportServiceServer will
// result in compilation errors.
type UnsafeDvirReportServiceServer interface {
	mustEmbedUnimplementedDvirReportServiceServer()
}

func RegisterDvirReportServiceServer(s grpc.ServiceRegistrar, srv DvirReportServiceServer) {
	s.RegisterService(&DvirReportService_ServiceDesc, srv)
}

func _DvirReportService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DvirReport)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DvirReportServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DvirReportService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DvirReportServiceServer).Create(ctx, req.(*DvirReport))
	}
	return interceptor(ctx, in, info, handler)
}

func _DvirReportService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DvirReportServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DvirReportService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DvirReportServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _DvirReportService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DvirReportServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DvirReportService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DvirReportServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _DvirReportService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DvirReport)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DvirReportServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DvirReportService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DvirReportServiceServer).Update(ctx, req.(*DvirReport))
	}
	return interceptor(ctx, in, info, handler)
}

func _DvirReportService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DvirReportServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DvirReportService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DvirReportServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

// DvirReportService_ServiceDesc is the grpc.ServiceDesc for DvirReportService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DvirReportService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "event_service.DvirReportService",
	HandlerType: (*DvirReportServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _DvirReportService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DvirReportService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _DvirReportService_Find_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _DvirReportService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _DvirReportService_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "event_service.proto",
}
