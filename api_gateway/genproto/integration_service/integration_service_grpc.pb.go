// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.12.4
// source: integration_service.proto

package integration_service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	HealthCheckService_HealthCheck_FullMethodName = "/integration_service.HealthCheckService/HealthCheck"
)

// HealthCheckServiceClient is the client API for HealthCheckService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthCheckServiceClient interface {
	HealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type healthCheckServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthCheckServiceClient(cc grpc.ClientConnInterface) HealthCheckServiceClient {
	return &healthCheckServiceClient{cc}
}

func (c *healthCheckServiceClient) HealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, HealthCheckService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthCheckServiceServer is the server API for HealthCheckService service.
// All implementations must embed UnimplementedHealthCheckServiceServer
// for forward compatibility
type HealthCheckServiceServer interface {
	HealthCheck(context.Context, *Empty) (*HealthCheckResponse, error)
	mustEmbedUnimplementedHealthCheckServiceServer()
}

// UnimplementedHealthCheckServiceServer must be embedded to have forward compatible implementations.
type UnimplementedHealthCheckServiceServer struct {
}

func (UnimplementedHealthCheckServiceServer) HealthCheck(context.Context, *Empty) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedHealthCheckServiceServer) mustEmbedUnimplementedHealthCheckServiceServer() {}

// UnsafeHealthCheckServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthCheckServiceServer will
// result in compilation errors.
type UnsafeHealthCheckServiceServer interface {
	mustEmbedUnimplementedHealthCheckServiceServer()
}

func RegisterHealthCheckServiceServer(s grpc.ServiceRegistrar, srv HealthCheckServiceServer) {
	s.RegisterService(&HealthCheckService_ServiceDesc, srv)
}

func _HealthCheckService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthCheckServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthCheckService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthCheckServiceServer).HealthCheck(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthCheckService_ServiceDesc is the grpc.ServiceDesc for HealthCheckService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthCheckService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_service.HealthCheckService",
	HandlerType: (*HealthCheckServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HealthCheck",
			Handler:    _HealthCheckService_HealthCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "integration_service.proto",
}

const (
	MapsService_GetList_FullMethodName     = "/integration_service.MapsService/GetList"
	MapsService_GetLocation_FullMethodName = "/integration_service.MapsService/GetLocation"
	MapsService_GetAdrres_FullMethodName   = "/integration_service.MapsService/GetAdrres"
)

// MapsServiceClient is the client API for MapsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MapsServiceClient interface {
	GetList(ctx context.Context, in *GetAddress, opts ...grpc.CallOption) (*AddressList, error)
	GetLocation(ctx context.Context, in *GetAddress, opts ...grpc.CallOption) (*Address, error)
	GetAdrres(ctx context.Context, in *GetFormatAddres, opts ...grpc.CallOption) (*AddressFormatList, error)
}

type mapsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMapsServiceClient(cc grpc.ClientConnInterface) MapsServiceClient {
	return &mapsServiceClient{cc}
}

func (c *mapsServiceClient) GetList(ctx context.Context, in *GetAddress, opts ...grpc.CallOption) (*AddressList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddressList)
	err := c.cc.Invoke(ctx, MapsService_GetList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapsServiceClient) GetLocation(ctx context.Context, in *GetAddress, opts ...grpc.CallOption) (*Address, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Address)
	err := c.cc.Invoke(ctx, MapsService_GetLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapsServiceClient) GetAdrres(ctx context.Context, in *GetFormatAddres, opts ...grpc.CallOption) (*AddressFormatList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddressFormatList)
	err := c.cc.Invoke(ctx, MapsService_GetAdrres_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MapsServiceServer is the server API for MapsService service.
// All implementations must embed UnimplementedMapsServiceServer
// for forward compatibility
type MapsServiceServer interface {
	GetList(context.Context, *GetAddress) (*AddressList, error)
	GetLocation(context.Context, *GetAddress) (*Address, error)
	GetAdrres(context.Context, *GetFormatAddres) (*AddressFormatList, error)
	mustEmbedUnimplementedMapsServiceServer()
}

// UnimplementedMapsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMapsServiceServer struct {
}

func (UnimplementedMapsServiceServer) GetList(context.Context, *GetAddress) (*AddressList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetList not implemented")
}
func (UnimplementedMapsServiceServer) GetLocation(context.Context, *GetAddress) (*Address, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocation not implemented")
}
func (UnimplementedMapsServiceServer) GetAdrres(context.Context, *GetFormatAddres) (*AddressFormatList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAdrres not implemented")
}
func (UnimplementedMapsServiceServer) mustEmbedUnimplementedMapsServiceServer() {}

// UnsafeMapsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MapsServiceServer will
// result in compilation errors.
type UnsafeMapsServiceServer interface {
	mustEmbedUnimplementedMapsServiceServer()
}

func RegisterMapsServiceServer(s grpc.ServiceRegistrar, srv MapsServiceServer) {
	s.RegisterService(&MapsService_ServiceDesc, srv)
}

func _MapsService_GetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapsServiceServer).GetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MapsService_GetList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapsServiceServer).GetList(ctx, req.(*GetAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _MapsService_GetLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapsServiceServer).GetLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MapsService_GetLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapsServiceServer).GetLocation(ctx, req.(*GetAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _MapsService_GetAdrres_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFormatAddres)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapsServiceServer).GetAdrres(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MapsService_GetAdrres_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapsServiceServer).GetAdrres(ctx, req.(*GetFormatAddres))
	}
	return interceptor(ctx, in, info, handler)
}

// MapsService_ServiceDesc is the grpc.ServiceDesc for MapsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MapsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_service.MapsService",
	HandlerType: (*MapsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetList",
			Handler:    _MapsService_GetList_Handler,
		},
		{
			MethodName: "GetLocation",
			Handler:    _MapsService_GetLocation_Handler,
		},
		{
			MethodName: "GetAdrres",
			Handler:    _MapsService_GetAdrres_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "integration_service.proto",
}

const (
	PaymentService_CreateMethod_FullMethodName   = "/integration_service.PaymentService/CreateMethod"
	PaymentService_GetMethod_FullMethodName      = "/integration_service.PaymentService/GetMethod"
	PaymentService_FindMethodList_FullMethodName = "/integration_service.PaymentService/FindMethodList"
	PaymentService_MakeMethodMain_FullMethodName = "/integration_service.PaymentService/MakeMethodMain"
	PaymentService_MakePayment_FullMethodName    = "/integration_service.PaymentService/MakePayment"
)

// PaymentServiceClient is the client API for PaymentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaymentServiceClient interface {
	CreateMethod(ctx context.Context, in *NewPaymentMethod, opts ...grpc.CallOption) (*PaymentMethod, error)
	GetMethod(ctx context.Context, in *PaymentMethodId, opts ...grpc.CallOption) (*PaymentMethod, error)
	FindMethodList(ctx context.Context, in *PaymentMethodId, opts ...grpc.CallOption) (*PaymentMethodList, error)
	MakeMethodMain(ctx context.Context, in *PaymentMethodId, opts ...grpc.CallOption) (*Empty, error)
	MakePayment(ctx context.Context, in *PaymentBody, opts ...grpc.CallOption) (*InvoiceList, error)
}

type paymentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPaymentServiceClient(cc grpc.ClientConnInterface) PaymentServiceClient {
	return &paymentServiceClient{cc}
}

func (c *paymentServiceClient) CreateMethod(ctx context.Context, in *NewPaymentMethod, opts ...grpc.CallOption) (*PaymentMethod, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentMethod)
	err := c.cc.Invoke(ctx, PaymentService_CreateMethod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) GetMethod(ctx context.Context, in *PaymentMethodId, opts ...grpc.CallOption) (*PaymentMethod, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentMethod)
	err := c.cc.Invoke(ctx, PaymentService_GetMethod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) FindMethodList(ctx context.Context, in *PaymentMethodId, opts ...grpc.CallOption) (*PaymentMethodList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentMethodList)
	err := c.cc.Invoke(ctx, PaymentService_FindMethodList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) MakeMethodMain(ctx context.Context, in *PaymentMethodId, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, PaymentService_MakeMethodMain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) MakePayment(ctx context.Context, in *PaymentBody, opts ...grpc.CallOption) (*InvoiceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InvoiceList)
	err := c.cc.Invoke(ctx, PaymentService_MakePayment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaymentServiceServer is the server API for PaymentService service.
// All implementations must embed UnimplementedPaymentServiceServer
// for forward compatibility
type PaymentServiceServer interface {
	CreateMethod(context.Context, *NewPaymentMethod) (*PaymentMethod, error)
	GetMethod(context.Context, *PaymentMethodId) (*PaymentMethod, error)
	FindMethodList(context.Context, *PaymentMethodId) (*PaymentMethodList, error)
	MakeMethodMain(context.Context, *PaymentMethodId) (*Empty, error)
	MakePayment(context.Context, *PaymentBody) (*InvoiceList, error)
	mustEmbedUnimplementedPaymentServiceServer()
}

// UnimplementedPaymentServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPaymentServiceServer struct {
}

func (UnimplementedPaymentServiceServer) CreateMethod(context.Context, *NewPaymentMethod) (*PaymentMethod, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMethod not implemented")
}
func (UnimplementedPaymentServiceServer) GetMethod(context.Context, *PaymentMethodId) (*PaymentMethod, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMethod not implemented")
}
func (UnimplementedPaymentServiceServer) FindMethodList(context.Context, *PaymentMethodId) (*PaymentMethodList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindMethodList not implemented")
}
func (UnimplementedPaymentServiceServer) MakeMethodMain(context.Context, *PaymentMethodId) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeMethodMain not implemented")
}
func (UnimplementedPaymentServiceServer) MakePayment(context.Context, *PaymentBody) (*InvoiceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakePayment not implemented")
}
func (UnimplementedPaymentServiceServer) mustEmbedUnimplementedPaymentServiceServer() {}

// UnsafePaymentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentServiceServer will
// result in compilation errors.
type UnsafePaymentServiceServer interface {
	mustEmbedUnimplementedPaymentServiceServer()
}

func RegisterPaymentServiceServer(s grpc.ServiceRegistrar, srv PaymentServiceServer) {
	s.RegisterService(&PaymentService_ServiceDesc, srv)
}

func _PaymentService_CreateMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewPaymentMethod)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).CreateMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_CreateMethod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).CreateMethod(ctx, req.(*NewPaymentMethod))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_GetMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentMethodId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).GetMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_GetMethod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).GetMethod(ctx, req.(*PaymentMethodId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_FindMethodList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentMethodId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).FindMethodList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_FindMethodList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).FindMethodList(ctx, req.(*PaymentMethodId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_MakeMethodMain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentMethodId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).MakeMethodMain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_MakeMethodMain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).MakeMethodMain(ctx, req.(*PaymentMethodId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_MakePayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentBody)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).MakePayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_MakePayment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).MakePayment(ctx, req.(*PaymentBody))
	}
	return interceptor(ctx, in, info, handler)
}

// PaymentService_ServiceDesc is the grpc.ServiceDesc for PaymentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaymentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_service.PaymentService",
	HandlerType: (*PaymentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMethod",
			Handler:    _PaymentService_CreateMethod_Handler,
		},
		{
			MethodName: "GetMethod",
			Handler:    _PaymentService_GetMethod_Handler,
		},
		{
			MethodName: "FindMethodList",
			Handler:    _PaymentService_FindMethodList_Handler,
		},
		{
			MethodName: "MakeMethodMain",
			Handler:    _PaymentService_MakeMethodMain_Handler,
		},
		{
			MethodName: "MakePayment",
			Handler:    _PaymentService_MakePayment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "integration_service.proto",
}
