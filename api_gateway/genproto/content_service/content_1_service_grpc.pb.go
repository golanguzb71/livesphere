// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.12.4
// source: content_1_service.proto

package content_service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	HealthCheckService_HealthCheck_FullMethodName = "/content_service.HealthCheckService/HealthCheck"
)

// HealthCheckServiceClient is the client API for HealthCheckService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthCheckServiceClient interface {
	HealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type healthCheckServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthCheckServiceClient(cc grpc.ClientConnInterface) HealthCheckServiceClient {
	return &healthCheckServiceClient{cc}
}

func (c *healthCheckServiceClient) HealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, HealthCheckService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthCheckServiceServer is the server API for HealthCheckService service.
// All implementations must embed UnimplementedHealthCheckServiceServer
// for forward compatibility
type HealthCheckServiceServer interface {
	HealthCheck(context.Context, *Empty) (*HealthCheckResponse, error)
	mustEmbedUnimplementedHealthCheckServiceServer()
}

// UnimplementedHealthCheckServiceServer must be embedded to have forward compatible implementations.
type UnimplementedHealthCheckServiceServer struct {
}

func (UnimplementedHealthCheckServiceServer) HealthCheck(context.Context, *Empty) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedHealthCheckServiceServer) mustEmbedUnimplementedHealthCheckServiceServer() {}

// UnsafeHealthCheckServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthCheckServiceServer will
// result in compilation errors.
type UnsafeHealthCheckServiceServer interface {
	mustEmbedUnimplementedHealthCheckServiceServer()
}

func RegisterHealthCheckServiceServer(s grpc.ServiceRegistrar, srv HealthCheckServiceServer) {
	s.RegisterService(&HealthCheckService_ServiceDesc, srv)
}

func _HealthCheckService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthCheckServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthCheckService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthCheckServiceServer).HealthCheck(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthCheckService_ServiceDesc is the grpc.ServiceDesc for HealthCheckService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthCheckService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "content_service.HealthCheckService",
	HandlerType: (*HealthCheckServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HealthCheck",
			Handler:    _HealthCheckService_HealthCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "content_1_service.proto",
}

const (
	TimezoneService_Create_FullMethodName = "/content_service.TimezoneService/Create"
	TimezoneService_Update_FullMethodName = "/content_service.TimezoneService/Update"
	TimezoneService_Delete_FullMethodName = "/content_service.TimezoneService/Delete"
	TimezoneService_Get_FullMethodName    = "/content_service.TimezoneService/Get"
	TimezoneService_Find_FullMethodName   = "/content_service.TimezoneService/Find"
)

// TimezoneServiceClient is the client API for TimezoneService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TimezoneServiceClient interface {
	Create(ctx context.Context, in *Timezone, opts ...grpc.CallOption) (*Timezone, error)
	Update(ctx context.Context, in *Timezone, opts ...grpc.CallOption) (*Timezone, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Timezone, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*TimezoneList, error)
}

type timezoneServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTimezoneServiceClient(cc grpc.ClientConnInterface) TimezoneServiceClient {
	return &timezoneServiceClient{cc}
}

func (c *timezoneServiceClient) Create(ctx context.Context, in *Timezone, opts ...grpc.CallOption) (*Timezone, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Timezone)
	err := c.cc.Invoke(ctx, TimezoneService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timezoneServiceClient) Update(ctx context.Context, in *Timezone, opts ...grpc.CallOption) (*Timezone, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Timezone)
	err := c.cc.Invoke(ctx, TimezoneService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timezoneServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TimezoneService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timezoneServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Timezone, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Timezone)
	err := c.cc.Invoke(ctx, TimezoneService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timezoneServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*TimezoneList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TimezoneList)
	err := c.cc.Invoke(ctx, TimezoneService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TimezoneServiceServer is the server API for TimezoneService service.
// All implementations must embed UnimplementedTimezoneServiceServer
// for forward compatibility
type TimezoneServiceServer interface {
	Create(context.Context, *Timezone) (*Timezone, error)
	Update(context.Context, *Timezone) (*Timezone, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*Timezone, error)
	Find(context.Context, *GetListFilter) (*TimezoneList, error)
	mustEmbedUnimplementedTimezoneServiceServer()
}

// UnimplementedTimezoneServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTimezoneServiceServer struct {
}

func (UnimplementedTimezoneServiceServer) Create(context.Context, *Timezone) (*Timezone, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedTimezoneServiceServer) Update(context.Context, *Timezone) (*Timezone, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedTimezoneServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTimezoneServiceServer) Get(context.Context, *Id) (*Timezone, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTimezoneServiceServer) Find(context.Context, *GetListFilter) (*TimezoneList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedTimezoneServiceServer) mustEmbedUnimplementedTimezoneServiceServer() {}

// UnsafeTimezoneServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TimezoneServiceServer will
// result in compilation errors.
type UnsafeTimezoneServiceServer interface {
	mustEmbedUnimplementedTimezoneServiceServer()
}

func RegisterTimezoneServiceServer(s grpc.ServiceRegistrar, srv TimezoneServiceServer) {
	s.RegisterService(&TimezoneService_ServiceDesc, srv)
}

func _TimezoneService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Timezone)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimezoneServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimezoneService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimezoneServiceServer).Create(ctx, req.(*Timezone))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimezoneService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Timezone)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimezoneServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimezoneService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimezoneServiceServer).Update(ctx, req.(*Timezone))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimezoneService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimezoneServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimezoneService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimezoneServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimezoneService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimezoneServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimezoneService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimezoneServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimezoneService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimezoneServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimezoneService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimezoneServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// TimezoneService_ServiceDesc is the grpc.ServiceDesc for TimezoneService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TimezoneService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "content_service.TimezoneService",
	HandlerType: (*TimezoneServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _TimezoneService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _TimezoneService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TimezoneService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TimezoneService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _TimezoneService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "content_1_service.proto",
}

const (
	CountryService_Create_FullMethodName = "/content_service.CountryService/Create"
	CountryService_Update_FullMethodName = "/content_service.CountryService/Update"
	CountryService_Delete_FullMethodName = "/content_service.CountryService/Delete"
	CountryService_Get_FullMethodName    = "/content_service.CountryService/Get"
	CountryService_Find_FullMethodName   = "/content_service.CountryService/Find"
)

// CountryServiceClient is the client API for CountryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CountryServiceClient interface {
	Create(ctx context.Context, in *Country, opts ...grpc.CallOption) (*Country, error)
	Update(ctx context.Context, in *Country, opts ...grpc.CallOption) (*Country, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Country, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*CountryList, error)
}

type countryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCountryServiceClient(cc grpc.ClientConnInterface) CountryServiceClient {
	return &countryServiceClient{cc}
}

func (c *countryServiceClient) Create(ctx context.Context, in *Country, opts ...grpc.CallOption) (*Country, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Country)
	err := c.cc.Invoke(ctx, CountryService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *countryServiceClient) Update(ctx context.Context, in *Country, opts ...grpc.CallOption) (*Country, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Country)
	err := c.cc.Invoke(ctx, CountryService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *countryServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, CountryService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *countryServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Country, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Country)
	err := c.cc.Invoke(ctx, CountryService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *countryServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*CountryList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CountryList)
	err := c.cc.Invoke(ctx, CountryService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CountryServiceServer is the server API for CountryService service.
// All implementations must embed UnimplementedCountryServiceServer
// for forward compatibility
type CountryServiceServer interface {
	Create(context.Context, *Country) (*Country, error)
	Update(context.Context, *Country) (*Country, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*Country, error)
	Find(context.Context, *GetListFilter) (*CountryList, error)
	mustEmbedUnimplementedCountryServiceServer()
}

// UnimplementedCountryServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCountryServiceServer struct {
}

func (UnimplementedCountryServiceServer) Create(context.Context, *Country) (*Country, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedCountryServiceServer) Update(context.Context, *Country) (*Country, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedCountryServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedCountryServiceServer) Get(context.Context, *Id) (*Country, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedCountryServiceServer) Find(context.Context, *GetListFilter) (*CountryList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedCountryServiceServer) mustEmbedUnimplementedCountryServiceServer() {}

// UnsafeCountryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CountryServiceServer will
// result in compilation errors.
type UnsafeCountryServiceServer interface {
	mustEmbedUnimplementedCountryServiceServer()
}

func RegisterCountryServiceServer(s grpc.ServiceRegistrar, srv CountryServiceServer) {
	s.RegisterService(&CountryService_ServiceDesc, srv)
}

func _CountryService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Country)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountryServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CountryService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountryServiceServer).Create(ctx, req.(*Country))
	}
	return interceptor(ctx, in, info, handler)
}

func _CountryService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Country)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountryServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CountryService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountryServiceServer).Update(ctx, req.(*Country))
	}
	return interceptor(ctx, in, info, handler)
}

func _CountryService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountryServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CountryService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountryServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _CountryService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountryServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CountryService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountryServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _CountryService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountryServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CountryService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountryServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// CountryService_ServiceDesc is the grpc.ServiceDesc for CountryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CountryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "content_service.CountryService",
	HandlerType: (*CountryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _CountryService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _CountryService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _CountryService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _CountryService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _CountryService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "content_1_service.proto",
}

const (
	StateService_Create_FullMethodName      = "/content_service.StateService/Create"
	StateService_Update_FullMethodName      = "/content_service.StateService/Update"
	StateService_Delete_FullMethodName      = "/content_service.StateService/Delete"
	StateService_Get_FullMethodName         = "/content_service.StateService/Get"
	StateService_Find_FullMethodName        = "/content_service.StateService/Find"
	StateService_MultipleGet_FullMethodName = "/content_service.StateService/MultipleGet"
)

// StateServiceClient is the client API for StateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StateServiceClient interface {
	Create(ctx context.Context, in *State, opts ...grpc.CallOption) (*State, error)
	Update(ctx context.Context, in *State, opts ...grpc.CallOption) (*State, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*State, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*StateList, error)
	MultipleGet(ctx context.Context, in *GetListRequest, opts ...grpc.CallOption) (*StateList, error)
}

type stateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStateServiceClient(cc grpc.ClientConnInterface) StateServiceClient {
	return &stateServiceClient{cc}
}

func (c *stateServiceClient) Create(ctx context.Context, in *State, opts ...grpc.CallOption) (*State, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(State)
	err := c.cc.Invoke(ctx, StateService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) Update(ctx context.Context, in *State, opts ...grpc.CallOption) (*State, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(State)
	err := c.cc.Invoke(ctx, StateService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, StateService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*State, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(State)
	err := c.cc.Invoke(ctx, StateService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*StateList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StateList)
	err := c.cc.Invoke(ctx, StateService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateServiceClient) MultipleGet(ctx context.Context, in *GetListRequest, opts ...grpc.CallOption) (*StateList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StateList)
	err := c.cc.Invoke(ctx, StateService_MultipleGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StateServiceServer is the server API for StateService service.
// All implementations must embed UnimplementedStateServiceServer
// for forward compatibility
type StateServiceServer interface {
	Create(context.Context, *State) (*State, error)
	Update(context.Context, *State) (*State, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*State, error)
	Find(context.Context, *GetListFilter) (*StateList, error)
	MultipleGet(context.Context, *GetListRequest) (*StateList, error)
	mustEmbedUnimplementedStateServiceServer()
}

// UnimplementedStateServiceServer must be embedded to have forward compatible implementations.
type UnimplementedStateServiceServer struct {
}

func (UnimplementedStateServiceServer) Create(context.Context, *State) (*State, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedStateServiceServer) Update(context.Context, *State) (*State, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedStateServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedStateServiceServer) Get(context.Context, *Id) (*State, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedStateServiceServer) Find(context.Context, *GetListFilter) (*StateList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedStateServiceServer) MultipleGet(context.Context, *GetListRequest) (*StateList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultipleGet not implemented")
}
func (UnimplementedStateServiceServer) mustEmbedUnimplementedStateServiceServer() {}

// UnsafeStateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StateServiceServer will
// result in compilation errors.
type UnsafeStateServiceServer interface {
	mustEmbedUnimplementedStateServiceServer()
}

func RegisterStateServiceServer(s grpc.ServiceRegistrar, srv StateServiceServer) {
	s.RegisterService(&StateService_ServiceDesc, srv)
}

func _StateService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(State)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Create(ctx, req.(*State))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(State)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Update(ctx, req.(*State))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateService_MultipleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServiceServer).MultipleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateService_MultipleGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServiceServer).MultipleGet(ctx, req.(*GetListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StateService_ServiceDesc is the grpc.ServiceDesc for StateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "content_service.StateService",
	HandlerType: (*StateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _StateService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _StateService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _StateService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _StateService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _StateService_Find_Handler,
		},
		{
			MethodName: "MultipleGet",
			Handler:    _StateService_MultipleGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "content_1_service.proto",
}

const (
	TruckMakeService_Create_FullMethodName = "/content_service.TruckMakeService/Create"
	TruckMakeService_Update_FullMethodName = "/content_service.TruckMakeService/Update"
	TruckMakeService_Delete_FullMethodName = "/content_service.TruckMakeService/Delete"
	TruckMakeService_Get_FullMethodName    = "/content_service.TruckMakeService/Get"
	TruckMakeService_Find_FullMethodName   = "/content_service.TruckMakeService/Find"
)

// TruckMakeServiceClient is the client API for TruckMakeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TruckMakeServiceClient interface {
	Create(ctx context.Context, in *TruckMake, opts ...grpc.CallOption) (*TruckMake, error)
	Update(ctx context.Context, in *TruckMake, opts ...grpc.CallOption) (*TruckMake, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*TruckMake, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*TruckMakesList, error)
}

type truckMakeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTruckMakeServiceClient(cc grpc.ClientConnInterface) TruckMakeServiceClient {
	return &truckMakeServiceClient{cc}
}

func (c *truckMakeServiceClient) Create(ctx context.Context, in *TruckMake, opts ...grpc.CallOption) (*TruckMake, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TruckMake)
	err := c.cc.Invoke(ctx, TruckMakeService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *truckMakeServiceClient) Update(ctx context.Context, in *TruckMake, opts ...grpc.CallOption) (*TruckMake, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TruckMake)
	err := c.cc.Invoke(ctx, TruckMakeService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *truckMakeServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TruckMakeService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *truckMakeServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*TruckMake, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TruckMake)
	err := c.cc.Invoke(ctx, TruckMakeService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *truckMakeServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*TruckMakesList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TruckMakesList)
	err := c.cc.Invoke(ctx, TruckMakeService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TruckMakeServiceServer is the server API for TruckMakeService service.
// All implementations must embed UnimplementedTruckMakeServiceServer
// for forward compatibility
type TruckMakeServiceServer interface {
	Create(context.Context, *TruckMake) (*TruckMake, error)
	Update(context.Context, *TruckMake) (*TruckMake, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*TruckMake, error)
	Find(context.Context, *GetListFilter) (*TruckMakesList, error)
	mustEmbedUnimplementedTruckMakeServiceServer()
}

// UnimplementedTruckMakeServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTruckMakeServiceServer struct {
}

func (UnimplementedTruckMakeServiceServer) Create(context.Context, *TruckMake) (*TruckMake, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedTruckMakeServiceServer) Update(context.Context, *TruckMake) (*TruckMake, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedTruckMakeServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTruckMakeServiceServer) Get(context.Context, *Id) (*TruckMake, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTruckMakeServiceServer) Find(context.Context, *GetListFilter) (*TruckMakesList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedTruckMakeServiceServer) mustEmbedUnimplementedTruckMakeServiceServer() {}

// UnsafeTruckMakeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TruckMakeServiceServer will
// result in compilation errors.
type UnsafeTruckMakeServiceServer interface {
	mustEmbedUnimplementedTruckMakeServiceServer()
}

func RegisterTruckMakeServiceServer(s grpc.ServiceRegistrar, srv TruckMakeServiceServer) {
	s.RegisterService(&TruckMakeService_ServiceDesc, srv)
}

func _TruckMakeService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TruckMake)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TruckMakeServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TruckMakeService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TruckMakeServiceServer).Create(ctx, req.(*TruckMake))
	}
	return interceptor(ctx, in, info, handler)
}

func _TruckMakeService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TruckMake)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TruckMakeServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TruckMakeService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TruckMakeServiceServer).Update(ctx, req.(*TruckMake))
	}
	return interceptor(ctx, in, info, handler)
}

func _TruckMakeService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TruckMakeServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TruckMakeService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TruckMakeServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TruckMakeService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TruckMakeServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TruckMakeService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TruckMakeServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TruckMakeService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TruckMakeServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TruckMakeService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TruckMakeServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// TruckMakeService_ServiceDesc is the grpc.ServiceDesc for TruckMakeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TruckMakeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "content_service.TruckMakeService",
	HandlerType: (*TruckMakeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _TruckMakeService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _TruckMakeService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TruckMakeService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TruckMakeService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _TruckMakeService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "content_1_service.proto",
}

const (
	TruckModelService_Create_FullMethodName = "/content_service.TruckModelService/Create"
	TruckModelService_Update_FullMethodName = "/content_service.TruckModelService/Update"
	TruckModelService_Delete_FullMethodName = "/content_service.TruckModelService/Delete"
	TruckModelService_Get_FullMethodName    = "/content_service.TruckModelService/Get"
	TruckModelService_Find_FullMethodName   = "/content_service.TruckModelService/Find"
)

// TruckModelServiceClient is the client API for TruckModelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TruckModelServiceClient interface {
	Create(ctx context.Context, in *TruckModel, opts ...grpc.CallOption) (*TruckModel, error)
	Update(ctx context.Context, in *TruckModel, opts ...grpc.CallOption) (*TruckModel, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*TruckModel, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*TruckModelList, error)
}

type truckModelServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTruckModelServiceClient(cc grpc.ClientConnInterface) TruckModelServiceClient {
	return &truckModelServiceClient{cc}
}

func (c *truckModelServiceClient) Create(ctx context.Context, in *TruckModel, opts ...grpc.CallOption) (*TruckModel, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TruckModel)
	err := c.cc.Invoke(ctx, TruckModelService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *truckModelServiceClient) Update(ctx context.Context, in *TruckModel, opts ...grpc.CallOption) (*TruckModel, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TruckModel)
	err := c.cc.Invoke(ctx, TruckModelService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *truckModelServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TruckModelService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *truckModelServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*TruckModel, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TruckModel)
	err := c.cc.Invoke(ctx, TruckModelService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *truckModelServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*TruckModelList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TruckModelList)
	err := c.cc.Invoke(ctx, TruckModelService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TruckModelServiceServer is the server API for TruckModelService service.
// All implementations must embed UnimplementedTruckModelServiceServer
// for forward compatibility
type TruckModelServiceServer interface {
	Create(context.Context, *TruckModel) (*TruckModel, error)
	Update(context.Context, *TruckModel) (*TruckModel, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*TruckModel, error)
	Find(context.Context, *GetListFilter) (*TruckModelList, error)
	mustEmbedUnimplementedTruckModelServiceServer()
}

// UnimplementedTruckModelServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTruckModelServiceServer struct {
}

func (UnimplementedTruckModelServiceServer) Create(context.Context, *TruckModel) (*TruckModel, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedTruckModelServiceServer) Update(context.Context, *TruckModel) (*TruckModel, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedTruckModelServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTruckModelServiceServer) Get(context.Context, *Id) (*TruckModel, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTruckModelServiceServer) Find(context.Context, *GetListFilter) (*TruckModelList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedTruckModelServiceServer) mustEmbedUnimplementedTruckModelServiceServer() {}

// UnsafeTruckModelServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TruckModelServiceServer will
// result in compilation errors.
type UnsafeTruckModelServiceServer interface {
	mustEmbedUnimplementedTruckModelServiceServer()
}

func RegisterTruckModelServiceServer(s grpc.ServiceRegistrar, srv TruckModelServiceServer) {
	s.RegisterService(&TruckModelService_ServiceDesc, srv)
}

func _TruckModelService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TruckModel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TruckModelServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TruckModelService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TruckModelServiceServer).Create(ctx, req.(*TruckModel))
	}
	return interceptor(ctx, in, info, handler)
}

func _TruckModelService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TruckModel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TruckModelServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TruckModelService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TruckModelServiceServer).Update(ctx, req.(*TruckModel))
	}
	return interceptor(ctx, in, info, handler)
}

func _TruckModelService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TruckModelServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TruckModelService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TruckModelServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TruckModelService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TruckModelServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TruckModelService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TruckModelServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TruckModelService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TruckModelServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TruckModelService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TruckModelServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// TruckModelService_ServiceDesc is the grpc.ServiceDesc for TruckModelService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TruckModelService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "content_service.TruckModelService",
	HandlerType: (*TruckModelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _TruckModelService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _TruckModelService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TruckModelService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TruckModelService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _TruckModelService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "content_1_service.proto",
}

const (
	FuelTypeService_Create_FullMethodName = "/content_service.FuelTypeService/Create"
	FuelTypeService_Update_FullMethodName = "/content_service.FuelTypeService/Update"
	FuelTypeService_Delete_FullMethodName = "/content_service.FuelTypeService/Delete"
	FuelTypeService_Get_FullMethodName    = "/content_service.FuelTypeService/Get"
	FuelTypeService_Find_FullMethodName   = "/content_service.FuelTypeService/Find"
)

// FuelTypeServiceClient is the client API for FuelTypeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FuelTypeServiceClient interface {
	Create(ctx context.Context, in *FuelType, opts ...grpc.CallOption) (*FuelType, error)
	Update(ctx context.Context, in *FuelType, opts ...grpc.CallOption) (*FuelType, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*FuelType, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*FuelTypeList, error)
}

type fuelTypeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFuelTypeServiceClient(cc grpc.ClientConnInterface) FuelTypeServiceClient {
	return &fuelTypeServiceClient{cc}
}

func (c *fuelTypeServiceClient) Create(ctx context.Context, in *FuelType, opts ...grpc.CallOption) (*FuelType, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuelType)
	err := c.cc.Invoke(ctx, FuelTypeService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fuelTypeServiceClient) Update(ctx context.Context, in *FuelType, opts ...grpc.CallOption) (*FuelType, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuelType)
	err := c.cc.Invoke(ctx, FuelTypeService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fuelTypeServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, FuelTypeService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fuelTypeServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*FuelType, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuelType)
	err := c.cc.Invoke(ctx, FuelTypeService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fuelTypeServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*FuelTypeList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FuelTypeList)
	err := c.cc.Invoke(ctx, FuelTypeService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FuelTypeServiceServer is the server API for FuelTypeService service.
// All implementations must embed UnimplementedFuelTypeServiceServer
// for forward compatibility
type FuelTypeServiceServer interface {
	Create(context.Context, *FuelType) (*FuelType, error)
	Update(context.Context, *FuelType) (*FuelType, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*FuelType, error)
	Find(context.Context, *GetListFilter) (*FuelTypeList, error)
	mustEmbedUnimplementedFuelTypeServiceServer()
}

// UnimplementedFuelTypeServiceServer must be embedded to have forward compatible implementations.
type UnimplementedFuelTypeServiceServer struct {
}

func (UnimplementedFuelTypeServiceServer) Create(context.Context, *FuelType) (*FuelType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedFuelTypeServiceServer) Update(context.Context, *FuelType) (*FuelType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedFuelTypeServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedFuelTypeServiceServer) Get(context.Context, *Id) (*FuelType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFuelTypeServiceServer) Find(context.Context, *GetListFilter) (*FuelTypeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedFuelTypeServiceServer) mustEmbedUnimplementedFuelTypeServiceServer() {}

// UnsafeFuelTypeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FuelTypeServiceServer will
// result in compilation errors.
type UnsafeFuelTypeServiceServer interface {
	mustEmbedUnimplementedFuelTypeServiceServer()
}

func RegisterFuelTypeServiceServer(s grpc.ServiceRegistrar, srv FuelTypeServiceServer) {
	s.RegisterService(&FuelTypeService_ServiceDesc, srv)
}

func _FuelTypeService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuelType)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuelTypeServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FuelTypeService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuelTypeServiceServer).Create(ctx, req.(*FuelType))
	}
	return interceptor(ctx, in, info, handler)
}

func _FuelTypeService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuelType)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuelTypeServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FuelTypeService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuelTypeServiceServer).Update(ctx, req.(*FuelType))
	}
	return interceptor(ctx, in, info, handler)
}

func _FuelTypeService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuelTypeServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FuelTypeService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuelTypeServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _FuelTypeService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuelTypeServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FuelTypeService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuelTypeServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _FuelTypeService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FuelTypeServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FuelTypeService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FuelTypeServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// FuelTypeService_ServiceDesc is the grpc.ServiceDesc for FuelTypeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FuelTypeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "content_service.FuelTypeService",
	HandlerType: (*FuelTypeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _FuelTypeService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _FuelTypeService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _FuelTypeService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FuelTypeService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _FuelTypeService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "content_1_service.proto",
}

const (
	ResourceService_Create_FullMethodName = "/content_service.ResourceService/Create"
	ResourceService_Update_FullMethodName = "/content_service.ResourceService/Update"
	ResourceService_Delete_FullMethodName = "/content_service.ResourceService/Delete"
	ResourceService_Get_FullMethodName    = "/content_service.ResourceService/Get"
	ResourceService_Find_FullMethodName   = "/content_service.ResourceService/Find"
)

// ResourceServiceClient is the client API for ResourceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ResourceServiceClient interface {
	Create(ctx context.Context, in *Resource, opts ...grpc.CallOption) (*Resource, error)
	Update(ctx context.Context, in *Resource, opts ...grpc.CallOption) (*Resource, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Resource, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ResourceList, error)
}

type resourceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewResourceServiceClient(cc grpc.ClientConnInterface) ResourceServiceClient {
	return &resourceServiceClient{cc}
}

func (c *resourceServiceClient) Create(ctx context.Context, in *Resource, opts ...grpc.CallOption) (*Resource, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Resource)
	err := c.cc.Invoke(ctx, ResourceService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourceServiceClient) Update(ctx context.Context, in *Resource, opts ...grpc.CallOption) (*Resource, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Resource)
	err := c.cc.Invoke(ctx, ResourceService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourceServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ResourceService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourceServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Resource, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Resource)
	err := c.cc.Invoke(ctx, ResourceService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourceServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ResourceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResourceList)
	err := c.cc.Invoke(ctx, ResourceService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ResourceServiceServer is the server API for ResourceService service.
// All implementations must embed UnimplementedResourceServiceServer
// for forward compatibility
type ResourceServiceServer interface {
	Create(context.Context, *Resource) (*Resource, error)
	Update(context.Context, *Resource) (*Resource, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*Resource, error)
	Find(context.Context, *GetListFilter) (*ResourceList, error)
	mustEmbedUnimplementedResourceServiceServer()
}

// UnimplementedResourceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedResourceServiceServer struct {
}

func (UnimplementedResourceServiceServer) Create(context.Context, *Resource) (*Resource, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedResourceServiceServer) Update(context.Context, *Resource) (*Resource, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedResourceServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedResourceServiceServer) Get(context.Context, *Id) (*Resource, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedResourceServiceServer) Find(context.Context, *GetListFilter) (*ResourceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedResourceServiceServer) mustEmbedUnimplementedResourceServiceServer() {}

// UnsafeResourceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ResourceServiceServer will
// result in compilation errors.
type UnsafeResourceServiceServer interface {
	mustEmbedUnimplementedResourceServiceServer()
}

func RegisterResourceServiceServer(s grpc.ServiceRegistrar, srv ResourceServiceServer) {
	s.RegisterService(&ResourceService_ServiceDesc, srv)
}

func _ResourceService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Resource)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourceService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceServiceServer).Create(ctx, req.(*Resource))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourceService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Resource)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourceService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceServiceServer).Update(ctx, req.(*Resource))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourceService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourceService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourceService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourceService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourceService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourceService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// ResourceService_ServiceDesc is the grpc.ServiceDesc for ResourceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ResourceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "content_service.ResourceService",
	HandlerType: (*ResourceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ResourceService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ResourceService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ResourceService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ResourceService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _ResourceService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "content_1_service.proto",
}

const (
	ResourceLinkService_Create_FullMethodName = "/content_service.ResourceLinkService/Create"
	ResourceLinkService_Update_FullMethodName = "/content_service.ResourceLinkService/Update"
	ResourceLinkService_Delete_FullMethodName = "/content_service.ResourceLinkService/Delete"
	ResourceLinkService_Get_FullMethodName    = "/content_service.ResourceLinkService/Get"
	ResourceLinkService_Find_FullMethodName   = "/content_service.ResourceLinkService/Find"
)

// ResourceLinkServiceClient is the client API for ResourceLinkService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ResourceLinkServiceClient interface {
	Create(ctx context.Context, in *ResourceLink, opts ...grpc.CallOption) (*ResourceLink, error)
	Update(ctx context.Context, in *ResourceLink, opts ...grpc.CallOption) (*ResourceLink, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ResourceLink, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ResourceLinkList, error)
}

type resourceLinkServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewResourceLinkServiceClient(cc grpc.ClientConnInterface) ResourceLinkServiceClient {
	return &resourceLinkServiceClient{cc}
}

func (c *resourceLinkServiceClient) Create(ctx context.Context, in *ResourceLink, opts ...grpc.CallOption) (*ResourceLink, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResourceLink)
	err := c.cc.Invoke(ctx, ResourceLinkService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourceLinkServiceClient) Update(ctx context.Context, in *ResourceLink, opts ...grpc.CallOption) (*ResourceLink, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResourceLink)
	err := c.cc.Invoke(ctx, ResourceLinkService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourceLinkServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ResourceLinkService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourceLinkServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ResourceLink, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResourceLink)
	err := c.cc.Invoke(ctx, ResourceLinkService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourceLinkServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*ResourceLinkList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResourceLinkList)
	err := c.cc.Invoke(ctx, ResourceLinkService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ResourceLinkServiceServer is the server API for ResourceLinkService service.
// All implementations must embed UnimplementedResourceLinkServiceServer
// for forward compatibility
type ResourceLinkServiceServer interface {
	Create(context.Context, *ResourceLink) (*ResourceLink, error)
	Update(context.Context, *ResourceLink) (*ResourceLink, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*ResourceLink, error)
	Find(context.Context, *GetListFilter) (*ResourceLinkList, error)
	mustEmbedUnimplementedResourceLinkServiceServer()
}

// UnimplementedResourceLinkServiceServer must be embedded to have forward compatible implementations.
type UnimplementedResourceLinkServiceServer struct {
}

func (UnimplementedResourceLinkServiceServer) Create(context.Context, *ResourceLink) (*ResourceLink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedResourceLinkServiceServer) Update(context.Context, *ResourceLink) (*ResourceLink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedResourceLinkServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedResourceLinkServiceServer) Get(context.Context, *Id) (*ResourceLink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedResourceLinkServiceServer) Find(context.Context, *GetListFilter) (*ResourceLinkList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedResourceLinkServiceServer) mustEmbedUnimplementedResourceLinkServiceServer() {}

// UnsafeResourceLinkServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ResourceLinkServiceServer will
// result in compilation errors.
type UnsafeResourceLinkServiceServer interface {
	mustEmbedUnimplementedResourceLinkServiceServer()
}

func RegisterResourceLinkServiceServer(s grpc.ServiceRegistrar, srv ResourceLinkServiceServer) {
	s.RegisterService(&ResourceLinkService_ServiceDesc, srv)
}

func _ResourceLinkService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceLink)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceLinkServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourceLinkService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceLinkServiceServer).Create(ctx, req.(*ResourceLink))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourceLinkService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceLink)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceLinkServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourceLinkService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceLinkServiceServer).Update(ctx, req.(*ResourceLink))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourceLinkService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceLinkServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourceLinkService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceLinkServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourceLinkService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceLinkServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourceLinkService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceLinkServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourceLinkService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourceLinkServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourceLinkService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourceLinkServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// ResourceLinkService_ServiceDesc is the grpc.ServiceDesc for ResourceLinkService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ResourceLinkService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "content_service.ResourceLinkService",
	HandlerType: (*ResourceLinkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ResourceLinkService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ResourceLinkService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ResourceLinkService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ResourceLinkService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _ResourceLinkService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "content_1_service.proto",
}

const (
	QuickStartService_Create_FullMethodName = "/content_service.QuickStartService/Create"
	QuickStartService_Update_FullMethodName = "/content_service.QuickStartService/Update"
	QuickStartService_Delete_FullMethodName = "/content_service.QuickStartService/Delete"
	QuickStartService_Get_FullMethodName    = "/content_service.QuickStartService/Get"
	QuickStartService_Find_FullMethodName   = "/content_service.QuickStartService/Find"
)

// QuickStartServiceClient is the client API for QuickStartService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QuickStartServiceClient interface {
	Create(ctx context.Context, in *QuickStart, opts ...grpc.CallOption) (*QuickStart, error)
	Update(ctx context.Context, in *QuickStart, opts ...grpc.CallOption) (*QuickStart, error)
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*QuickStart, error)
	Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*QuickStartList, error)
}

type quickStartServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewQuickStartServiceClient(cc grpc.ClientConnInterface) QuickStartServiceClient {
	return &quickStartServiceClient{cc}
}

func (c *quickStartServiceClient) Create(ctx context.Context, in *QuickStart, opts ...grpc.CallOption) (*QuickStart, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuickStart)
	err := c.cc.Invoke(ctx, QuickStartService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quickStartServiceClient) Update(ctx context.Context, in *QuickStart, opts ...grpc.CallOption) (*QuickStart, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuickStart)
	err := c.cc.Invoke(ctx, QuickStartService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quickStartServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, QuickStartService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quickStartServiceClient) Get(ctx context.Context, in *Id, opts ...grpc.CallOption) (*QuickStart, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuickStart)
	err := c.cc.Invoke(ctx, QuickStartService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quickStartServiceClient) Find(ctx context.Context, in *GetListFilter, opts ...grpc.CallOption) (*QuickStartList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuickStartList)
	err := c.cc.Invoke(ctx, QuickStartService_Find_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QuickStartServiceServer is the server API for QuickStartService service.
// All implementations must embed UnimplementedQuickStartServiceServer
// for forward compatibility
type QuickStartServiceServer interface {
	Create(context.Context, *QuickStart) (*QuickStart, error)
	Update(context.Context, *QuickStart) (*QuickStart, error)
	Delete(context.Context, *Id) (*Empty, error)
	Get(context.Context, *Id) (*QuickStart, error)
	Find(context.Context, *GetListFilter) (*QuickStartList, error)
	mustEmbedUnimplementedQuickStartServiceServer()
}

// UnimplementedQuickStartServiceServer must be embedded to have forward compatible implementations.
type UnimplementedQuickStartServiceServer struct {
}

func (UnimplementedQuickStartServiceServer) Create(context.Context, *QuickStart) (*QuickStart, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedQuickStartServiceServer) Update(context.Context, *QuickStart) (*QuickStart, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedQuickStartServiceServer) Delete(context.Context, *Id) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedQuickStartServiceServer) Get(context.Context, *Id) (*QuickStart, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedQuickStartServiceServer) Find(context.Context, *GetListFilter) (*QuickStartList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (UnimplementedQuickStartServiceServer) mustEmbedUnimplementedQuickStartServiceServer() {}

// UnsafeQuickStartServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QuickStartServiceServer will
// result in compilation errors.
type UnsafeQuickStartServiceServer interface {
	mustEmbedUnimplementedQuickStartServiceServer()
}

func RegisterQuickStartServiceServer(s grpc.ServiceRegistrar, srv QuickStartServiceServer) {
	s.RegisterService(&QuickStartService_ServiceDesc, srv)
}

func _QuickStartService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuickStart)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuickStartServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuickStartService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuickStartServiceServer).Create(ctx, req.(*QuickStart))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuickStartService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuickStart)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuickStartServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuickStartService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuickStartServiceServer).Update(ctx, req.(*QuickStart))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuickStartService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuickStartServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuickStartService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuickStartServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuickStartService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuickStartServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuickStartService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuickStartServiceServer).Get(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuickStartService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuickStartServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuickStartService_Find_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuickStartServiceServer).Find(ctx, req.(*GetListFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// QuickStartService_ServiceDesc is the grpc.ServiceDesc for QuickStartService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QuickStartService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "content_service.QuickStartService",
	HandlerType: (*QuickStartServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _QuickStartService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _QuickStartService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _QuickStartService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _QuickStartService_Get_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _QuickStartService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "content_1_service.proto",
}
